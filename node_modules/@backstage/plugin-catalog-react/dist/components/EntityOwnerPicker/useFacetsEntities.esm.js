import { useApi } from '@backstage/core-plugin-api';
import useAsyncFn from 'react-use/esm/useAsyncFn';
import { catalogApiRef } from '../../api.esm.js';
import { useState } from 'react';
import get from 'lodash/get';

function useFacetsEntities({ enabled }) {
  const catalogApi = useApi(catalogApiRef);
  const [facetsPromise] = useState(async () => {
    if (!enabled) {
      return [];
    }
    const facet = "relations.ownedBy";
    const facetsResponse = await catalogApi.getEntityFacets({
      facets: [facet]
    });
    const entityRefs = facetsResponse.facets[facet].map((e) => e.value);
    return catalogApi.getEntitiesByRefs({ entityRefs }).then(
      (resp) => resp.items.filter((entity) => entity !== void 0).map((entity) => entity).sort(
        (a, b) => (a.metadata.namespace || "").localeCompare(
          b.metadata.namespace || "",
          "en-US"
        ) || (get(a, "spec.profile.displayName") || a.metadata.title || a.metadata.name).localeCompare(
          get(b, "spec.profile.displayName") || b.metadata.title || b.metadata.name,
          "en-US"
        ) || a.kind.localeCompare(b.kind, "en-US")
      )
    ).then((entities) => entities).catch(() => []);
  });
  return useAsyncFn(
    async (request, options) => {
      const facets = await facetsPromise;
      if (!facets) {
        return {
          items: []
        };
      }
      const limit = options?.limit ?? 20;
      const { text, start } = decodeCursor(request);
      const filteredRefs = facets.filter((e) => filterEntity(text, e));
      const end = start + limit;
      return {
        items: filteredRefs.slice(0, end),
        ...encodeCursor({
          entities: filteredRefs,
          limit: end,
          payload: {
            text,
            start: end
          }
        })
      };
    },
    [facetsPromise],
    { loading: true, value: { items: [] } }
  );
}
function decodeCursor(request) {
  if (isFacetsResponse(request) && request.cursor) {
    return JSON.parse(atob(request.cursor));
  }
  return {
    text: request.text || "",
    start: 0
  };
}
function isFacetsResponse(request) {
  return !!request.cursor;
}
function encodeCursor({
  entities,
  limit,
  payload
}) {
  if (entities.length > limit) {
    return { cursor: btoa(JSON.stringify(payload)) };
  }
  return {};
}
function filterEntity(text, entity) {
  const normalizedText = text.trim();
  return entity.kind.includes(normalizedText) || entity.metadata.namespace?.includes(normalizedText) || entity.metadata.name.includes(normalizedText) || entity.metadata.title?.includes(normalizedText) || get(entity, "spec.profile.displayName")?.includes(
    normalizedText
  );
}

export { useFacetsEntities };
//# sourceMappingURL=useFacetsEntities.esm.js.map
