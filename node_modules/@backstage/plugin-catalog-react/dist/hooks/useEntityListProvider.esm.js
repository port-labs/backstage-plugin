import { compact, isEqual } from 'lodash';
import qs from 'qs';
import React, { createContext, useState, useMemo, useCallback, useContext } from 'react';
import { useLocation } from 'react-router-dom';
import useAsyncFn from 'react-use/esm/useAsyncFn';
import useDebounce from 'react-use/esm/useDebounce';
import useMountedState from 'react-use/esm/useMountedState';
import { catalogApiRef } from '../api.esm.js';
import { reduceCatalogFilters, reduceBackendCatalogFilters, reduceEntityFilters } from '../utils/filters.esm.js';
import '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';

const EntityListContext = createContext(void 0);
const EntityListProvider = (props) => {
  const isMounted = useMountedState();
  const catalogApi = useApi(catalogApiRef);
  const [requestedFilters, setRequestedFilters] = useState(
    {}
  );
  const location = useLocation();
  const enablePagination = props.pagination === true || typeof props.pagination === "object";
  const limit = props.pagination && typeof props.pagination === "object" && typeof props.pagination.limit === "number" ? props.pagination.limit : 20;
  const { queryParameters, cursor: initialCursor } = useMemo(() => {
    const parsed = qs.parse(location.search, {
      ignoreQueryPrefix: true
    });
    return {
      queryParameters: parsed.filters ?? {},
      cursor: typeof parsed.cursor === "string" ? parsed.cursor : void 0
    };
  }, [location]);
  const [cursor, setCursor] = useState(initialCursor);
  const [outputState, setOutputState] = useState(
    () => {
      return {
        appliedFilters: {},
        entities: [],
        backendEntities: [],
        pageInfo: enablePagination ? {} : void 0
      };
    }
  );
  const [{ loading, error }, refresh] = useAsyncFn(
    async () => {
      const compacted = compact(Object.values(requestedFilters));
      const queryParams = Object.keys(requestedFilters).reduce(
        (params, key) => {
          const filter = requestedFilters[key];
          if (filter?.toQueryValue) {
            params[key] = filter.toQueryValue();
          }
          return params;
        },
        {}
      );
      if (enablePagination) {
        if (cursor) {
          if (cursor !== outputState.appliedCursor) {
            const entityFilter = reduceEntityFilters(compacted);
            const response = await catalogApi.queryEntities({
              cursor,
              limit
            });
            setOutputState({
              appliedFilters: requestedFilters,
              appliedCursor: cursor,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo,
              totalItems: response.totalItems
            });
          }
        } else {
          const entityFilter = reduceEntityFilters(compacted);
          const backendFilter = reduceCatalogFilters(compacted);
          const previousBackendFilter = reduceCatalogFilters(
            compact(Object.values(outputState.appliedFilters))
          );
          if (!isEqual(previousBackendFilter, backendFilter)) {
            const response = await catalogApi.queryEntities({
              ...backendFilter,
              limit,
              orderFields: [{ field: "metadata.name", order: "asc" }]
            });
            setOutputState({
              appliedFilters: requestedFilters,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo,
              totalItems: response.totalItems
            });
          }
        }
      } else {
        const entityFilter = reduceEntityFilters(compacted);
        const backendFilter = reduceBackendCatalogFilters(compacted);
        const previousBackendFilter = reduceBackendCatalogFilters(
          compact(Object.values(outputState.appliedFilters))
        );
        if (!isEqual(previousBackendFilter, backendFilter)) {
          const response = await catalogApi.getEntities({
            filter: backendFilter
          });
          const entities = response.items.filter(entityFilter);
          setOutputState({
            appliedFilters: requestedFilters,
            backendEntities: response.items,
            entities,
            totalItems: entities.length
          });
        } else {
          const entities = outputState.backendEntities.filter(entityFilter);
          setOutputState({
            appliedFilters: requestedFilters,
            backendEntities: outputState.backendEntities,
            entities,
            totalItems: entities.length
          });
        }
      }
      if (isMounted()) {
        const oldParams = qs.parse(location.search, {
          ignoreQueryPrefix: true
        });
        const newParams = qs.stringify(
          { ...oldParams, filters: queryParams, cursor },
          { addQueryPrefix: true, arrayFormat: "repeat" }
        );
        const newUrl = `${window.location.pathname}${newParams}`;
        window.history?.replaceState(null, document.title, newUrl);
      }
    },
    [
      catalogApi,
      queryParameters,
      requestedFilters,
      outputState,
      cursor,
      enablePagination
    ],
    { loading: true }
  );
  useDebounce(refresh, 10, [requestedFilters, cursor]);
  const updateFilters = useCallback(
    (update) => {
      setCursor(void 0);
      setRequestedFilters((prevFilters) => {
        const newFilters = typeof update === "function" ? update(prevFilters) : update;
        return { ...prevFilters, ...newFilters };
      });
    },
    []
  );
  const pageInfo = useMemo(() => {
    if (!enablePagination) {
      return void 0;
    }
    const prevCursor = outputState.pageInfo?.prevCursor;
    const nextCursor = outputState.pageInfo?.nextCursor;
    return {
      prev: prevCursor ? () => setCursor(prevCursor) : void 0,
      next: nextCursor ? () => setCursor(nextCursor) : void 0
    };
  }, [enablePagination, outputState.pageInfo]);
  const value = useMemo(
    () => ({
      filters: outputState.appliedFilters,
      entities: outputState.entities,
      backendEntities: outputState.backendEntities,
      updateFilters,
      queryParameters,
      loading,
      error,
      pageInfo,
      totalItems: outputState.totalItems
    }),
    [outputState, updateFilters, queryParameters, loading, error, pageInfo]
  );
  return /* @__PURE__ */ React.createElement(EntityListContext.Provider, { value }, props.children);
};
function useEntityList() {
  const context = useContext(EntityListContext);
  if (!context)
    throw new Error("useEntityList must be used within EntityListProvider");
  return context;
}

export { EntityListContext, EntityListProvider, useEntityList };
//# sourceMappingURL=useEntityListProvider.esm.js.map
