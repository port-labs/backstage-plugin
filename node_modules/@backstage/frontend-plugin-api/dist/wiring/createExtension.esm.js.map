{"version":3,"file":"createExtension.esm.js","sources":["../../src/wiring/createExtension.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppNode } from '../apis';\nimport { PortableSchema, createSchemaFromZod } from '../schema';\nimport { Expand } from '../types';\nimport {\n  ResolveInputValueOverrides,\n  resolveInputOverrides,\n} from './resolveInputOverrides';\nimport {\n  ExtensionDataContainer,\n  createExtensionDataContainer,\n} from './createExtensionDataContainer';\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\nimport { ExtensionInput, LegacyExtensionInput } from './createExtensionInput';\nimport { z } from 'zod';\n\n/**\n * @public\n * @deprecated Extension data maps will be removed.\n */\nexport type AnyExtensionDataMap = {\n  [name in string]: AnyExtensionDataRef;\n};\n\n/**\n * @public\n * @deprecated This type will be removed.\n */\nexport type AnyExtensionInputMap = {\n  [inputName in string]: LegacyExtensionInput<\n    AnyExtensionDataMap,\n    { optional: boolean; singleton: boolean }\n  >;\n};\n\n/**\n * Converts an extension data map into the matching concrete data values type.\n * @public\n * @deprecated Extension data maps will be removed.\n */\nexport type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {\n  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {\n    optional: true;\n  }\n    ? never\n    : DataName]: TExtensionData[DataName]['T'];\n} & {\n  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {\n    optional: true;\n  }\n    ? DataName\n    : never]?: TExtensionData[DataName]['T'];\n};\n\n/**\n * Convert a single extension input into a matching resolved input.\n * @public\n */\nexport type ResolvedExtensionInput<\n  TExtensionInput extends ExtensionInput<any, any>,\n> = TExtensionInput['extensionData'] extends Array<AnyExtensionDataRef>\n  ? {\n      node: AppNode;\n    } & ExtensionDataContainer<TExtensionInput['extensionData'][number]>\n  : TExtensionInput['extensionData'] extends AnyExtensionDataMap\n  ? {\n      node: AppNode;\n      output: ExtensionDataValues<TExtensionInput['extensionData']>;\n    }\n  : never;\n\n/**\n * Converts an extension input map into a matching collection of resolved inputs.\n * @public\n */\nexport type ResolvedExtensionInputs<\n  TInputs extends {\n    [name in string]: ExtensionInput<any, any> | LegacyExtensionInput<any, any>;\n  },\n> = {\n  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']\n    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>>\n    : false extends TInputs[InputName]['config']['optional']\n    ? Expand<ResolvedExtensionInput<TInputs[InputName]>>\n    : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;\n};\n\n/**\n * @public\n * @deprecated This way of structuring the options is deprecated, this type will be removed in the future\n */\nexport interface LegacyCreateExtensionOptions<\n  TOutput extends AnyExtensionDataMap,\n  TInputs extends AnyExtensionInputMap,\n  TConfig,\n  TConfigInput,\n> {\n  kind?: string;\n  namespace?: string;\n  name?: string;\n  attachTo: { id: string; input: string };\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: TOutput;\n  configSchema?: PortableSchema<TConfig, TConfigInput>;\n  factory(context: {\n    node: AppNode;\n    config: TConfig;\n    inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n  }): Expand<ExtensionDataValues<TOutput>>;\n}\n\ntype ToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never;\n\ntype PopUnion<U> = ToIntersection<\n  U extends any ? () => U : never\n> extends () => infer R\n  ? [rest: Exclude<U, R>, next: R]\n  : undefined;\n\n/** @ignore */\ntype JoinStringUnion<\n  U,\n  TDiv extends string = ', ',\n  TResult extends string = '',\n> = PopUnion<U> extends [infer IRest extends string, infer INext extends string]\n  ? TResult extends ''\n    ? JoinStringUnion<IRest, TDiv, INext>\n    : JoinStringUnion<IRest, TDiv, `${TResult}${TDiv}${INext}`>\n  : TResult;\n\n/** @ignore */\nexport type VerifyExtensionFactoryOutput<\n  UDeclaredOutput extends AnyExtensionDataRef,\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n> = (\n  UDeclaredOutput extends any\n    ? UDeclaredOutput['config']['optional'] extends true\n      ? never\n      : UDeclaredOutput['id']\n    : never\n) extends infer IRequiredOutputIds\n  ? [IRequiredOutputIds] extends [UFactoryOutput['id']]\n    ? [UFactoryOutput['id']] extends [UDeclaredOutput['id']]\n      ? {}\n      : `Error: The extension factory has undeclared output(s): ${JoinStringUnion<\n          Exclude<UFactoryOutput['id'], UDeclaredOutput['id']>\n        >}`\n    : `Error: The extension factory is missing the following output(s): ${JoinStringUnion<\n        Exclude<IRequiredOutputIds, UFactoryOutput['id']>\n      >}`\n  : never;\n\n/** @public */\nexport type CreateExtensionOptions<\n  TKind extends string | undefined,\n  TNamespace extends string | undefined,\n  TName extends string | undefined,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n> = {\n  kind?: TKind;\n  namespace?: TNamespace;\n  name?: TName;\n  attachTo: { id: string; input: string };\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: Array<UOutput>;\n  config?: {\n    schema: TConfigSchema;\n  };\n  factory(context: {\n    node: AppNode;\n    config: {\n      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n    };\n    inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n  }): Iterable<UFactoryOutput>;\n} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;\n\n/** @public */\nexport interface ExtensionDefinition<\n  TConfig,\n  TConfigInput = TConfig,\n  UOutput extends AnyExtensionDataRef = AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  } = {},\n  TIdParts extends {\n    kind?: string;\n    namespace?: string;\n    name?: string;\n  } = {\n    kind?: string;\n    namespace?: string;\n    name?: string;\n  },\n> {\n  $$type: '@backstage/ExtensionDefinition';\n  readonly kind?: TIdParts['kind'];\n  readonly namespace?: TIdParts['namespace'];\n  readonly name?: TIdParts['name'];\n  readonly attachTo: { id: string; input: string };\n  readonly disabled: boolean;\n  readonly configSchema?: PortableSchema<TConfig, TConfigInput>;\n\n  override<\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends AnyExtensionDataRef,\n    TExtraInputs extends {\n      [inputName in string]: ExtensionInput<\n        AnyExtensionDataRef,\n        { optional: boolean; singleton: boolean }\n      >;\n    },\n  >(\n    args: {\n      attachTo?: { id: string; input: string };\n      disabled?: boolean;\n      inputs?: TExtraInputs & {\n        [KName in keyof TInputs]?: `Error: Input '${KName &\n          string}' is already defined in parent definition`;\n      };\n      output?: Array<UNewOutput>;\n      config?: {\n        schema: TExtensionConfigSchema & {\n          [KName in keyof TConfig]?: `Error: Config key '${KName &\n            string}' is already defined in parent schema`;\n        };\n      };\n      factory(\n        originalFactory: (context?: {\n          config?: TConfig;\n          inputs?: ResolveInputValueOverrides<TInputs>;\n        }) => ExtensionDataContainer<UOutput>,\n        context: {\n          node: AppNode;\n          config: TConfig & {\n            [key in keyof TExtensionConfigSchema]: z.infer<\n              ReturnType<TExtensionConfigSchema[key]>\n            >;\n          };\n          inputs: Expand<ResolvedExtensionInputs<TInputs & TExtraInputs>>;\n        },\n      ): Iterable<UFactoryOutput>;\n    } & VerifyExtensionFactoryOutput<\n      AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput,\n      UFactoryOutput\n    >,\n  ): ExtensionDefinition<\n    {\n      [key in keyof TExtensionConfigSchema]: z.infer<\n        ReturnType<TExtensionConfigSchema[key]>\n      >;\n    } & TConfig,\n    z.input<\n      z.ZodObject<{\n        [key in keyof TExtensionConfigSchema]: ReturnType<\n          TExtensionConfigSchema[key]\n        >;\n      }>\n    > &\n      TConfigInput,\n    AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput,\n    TInputs & TExtraInputs,\n    TIdParts\n  >;\n}\n\n/** @internal */\nexport type InternalExtensionDefinition<\n  TConfig,\n  TConfigInput = TConfig,\n  UOutput extends AnyExtensionDataRef = AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  } = {},\n  TIdParts extends {\n    kind?: string;\n    namespace?: string;\n    name?: string;\n  } = {\n    kind?: string;\n    namespace?: string;\n    name?: string;\n  },\n> = ExtensionDefinition<TConfig, TConfigInput, UOutput, TInputs, TIdParts> &\n  (\n    | {\n        readonly version: 'v1';\n        readonly inputs: AnyExtensionInputMap;\n        readonly output: AnyExtensionDataMap;\n        factory(context: {\n          node: AppNode;\n          config: TConfig;\n          inputs: ResolvedExtensionInputs<AnyExtensionInputMap>;\n        }): ExtensionDataValues<any>;\n      }\n    | {\n        readonly version: 'v2';\n        readonly inputs: {\n          [inputName in string]: ExtensionInput<\n            AnyExtensionDataRef,\n            { optional: boolean; singleton: boolean }\n          >;\n        };\n        readonly output: Array<AnyExtensionDataRef>;\n        factory(context: {\n          node: AppNode;\n          config: TConfig;\n          inputs: ResolvedExtensionInputs<{\n            [inputName in string]: ExtensionInput<\n              AnyExtensionDataRef,\n              { optional: boolean; singleton: boolean }\n            >;\n          }>;\n        }): Iterable<ExtensionDataValue<any, any>>;\n      }\n  );\n\n/** @internal */\nexport function toInternalExtensionDefinition<TConfig, TConfigInput>(\n  overrides: ExtensionDefinition<TConfig, TConfigInput>,\n): InternalExtensionDefinition<TConfig, TConfigInput> {\n  const internal = overrides as InternalExtensionDefinition<\n    TConfig,\n    TConfigInput\n  >;\n  if (internal.$$type !== '@backstage/ExtensionDefinition') {\n    throw new Error(\n      `Invalid extension definition instance, bad type '${internal.$$type}'`,\n    );\n  }\n  const version = internal.version;\n  if (version !== 'v1' && version !== 'v2') {\n    throw new Error(\n      `Invalid extension definition instance, bad version '${version}'`,\n    );\n  }\n  return internal;\n}\n\n/** @public */\nexport function createExtension<\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  const TKind extends string | undefined = undefined,\n  const TNamespace extends string | undefined = undefined,\n  const TName extends string | undefined = undefined,\n>(\n  options: CreateExtensionOptions<\n    TKind,\n    TNamespace,\n    TName,\n    UOutput,\n    TInputs,\n    TConfigSchema,\n    UFactoryOutput\n  >,\n): ExtensionDefinition<\n  {\n    [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n  },\n  z.input<\n    z.ZodObject<{\n      [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n    }>\n  >,\n  UOutput,\n  TInputs,\n  {\n    kind: string | undefined extends TKind ? undefined : TKind;\n    namespace: string | undefined extends TNamespace ? undefined : TNamespace;\n    name: string | undefined extends TName ? undefined : TName;\n  }\n>;\n/**\n * @public\n * @deprecated - use the array format of `output` instead, see TODO-doc-link\n */\nexport function createExtension<\n  TOutput extends AnyExtensionDataMap,\n  TInputs extends AnyExtensionInputMap,\n  TConfig,\n  TConfigInput,\n>(\n  options: LegacyCreateExtensionOptions<\n    TOutput,\n    TInputs,\n    TConfig,\n    TConfigInput\n  >,\n): ExtensionDefinition<TConfig, TConfigInput, never, never>;\nexport function createExtension<\n  const TKind extends string | undefined,\n  const TNamespace extends string | undefined,\n  const TName extends string | undefined,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TLegacyInputs extends AnyExtensionInputMap,\n  TConfig,\n  TConfigInput,\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n>(\n  options:\n    | CreateExtensionOptions<\n        TKind,\n        TNamespace,\n        TName,\n        UOutput,\n        TInputs,\n        TConfigSchema,\n        UFactoryOutput\n      >\n    | LegacyCreateExtensionOptions<\n        AnyExtensionDataMap,\n        TLegacyInputs,\n        TConfig,\n        TConfigInput\n      >,\n): ExtensionDefinition<\n  TConfig &\n    (string extends keyof TConfigSchema\n      ? {}\n      : {\n          [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n        }),\n  TConfigInput &\n    (string extends keyof TConfigSchema\n      ? {}\n      : z.input<\n          z.ZodObject<{\n            [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n          }>\n        >),\n  UOutput,\n  TInputs,\n  {\n    kind: TKind;\n    namespace: TNamespace;\n    name: TName;\n  }\n> {\n  if ('configSchema' in options && 'config' in options) {\n    throw new Error(`Cannot provide both configSchema and config.schema`);\n  }\n  let configSchema: PortableSchema<any, any> | undefined;\n  if ('configSchema' in options) {\n    configSchema = options.configSchema;\n  }\n  if ('config' in options) {\n    const newConfigSchema = options.config?.schema;\n    configSchema =\n      newConfigSchema &&\n      createSchemaFromZod(innerZ =>\n        innerZ.object(\n          Object.fromEntries(\n            Object.entries(newConfigSchema).map(([k, v]) => [k, v(innerZ)]),\n          ),\n        ),\n      );\n  }\n\n  return {\n    $$type: '@backstage/ExtensionDefinition',\n    version: Symbol.iterator in options.output ? 'v2' : 'v1',\n    kind: options.kind,\n    namespace: options.namespace,\n    name: options.name,\n    attachTo: options.attachTo,\n    disabled: options.disabled ?? false,\n    inputs: options.inputs ?? {},\n    output: options.output,\n    configSchema,\n    factory: options.factory,\n    toString() {\n      const parts: string[] = [];\n      if (options.kind) {\n        parts.push(`kind=${options.kind}`);\n      }\n      if (options.namespace) {\n        parts.push(`namespace=${options.namespace}`);\n      }\n      if (options.name) {\n        parts.push(`name=${options.name}`);\n      }\n      parts.push(`attachTo=${options.attachTo.id}@${options.attachTo.input}`);\n      return `ExtensionDefinition{${parts.join(',')}}`;\n    },\n    override: <\n      TExtensionConfigSchema extends {\n        [key in string]: (zImpl: typeof z) => z.ZodType;\n      },\n      UOverrideFactoryOutput extends ExtensionDataValue<any, any>,\n      UNewOutput extends AnyExtensionDataRef,\n      TExtraInputs extends {\n        [inputName in string]: ExtensionInput<\n          AnyExtensionDataRef,\n          { optional: boolean; singleton: boolean }\n        >;\n      },\n    >(overrideOptions: {\n      attachTo?: { id: string; input: string };\n      disabled?: boolean;\n      inputs?: TExtraInputs;\n      output?: Array<UNewOutput>;\n      config?: {\n        schema: TExtensionConfigSchema;\n      };\n      factory(\n        originalFactory: (context?: {\n          config?: {\n            [key in keyof TConfigSchema]: z.infer<\n              ReturnType<TConfigSchema[key]>\n            >;\n          };\n          inputs?: ResolveInputValueOverrides<TInputs>;\n        }) => ExtensionDataContainer<UOutput>,\n        context: {\n          node: AppNode;\n          config: {\n            [key in keyof TExtensionConfigSchema]: z.infer<\n              ReturnType<TExtensionConfigSchema[key]>\n            >;\n          } & {\n            [key in keyof TConfigSchema]: z.infer<\n              ReturnType<TConfigSchema[key]>\n            >;\n          };\n          inputs: Expand<ResolvedExtensionInputs<TInputs & TExtraInputs>>;\n        },\n      ): Iterable<UOverrideFactoryOutput>;\n    }): ExtensionDefinition<\n      {\n        [key in keyof TExtensionConfigSchema]: z.infer<\n          ReturnType<TExtensionConfigSchema[key]>\n        >;\n      } & {\n        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n      },\n      z.input<\n        z.ZodObject<\n          {\n            [key in keyof TExtensionConfigSchema]: ReturnType<\n              TExtensionConfigSchema[key]\n            >;\n          } & {\n            [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n          }\n        >\n      >,\n      AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput,\n      TInputs & TExtraInputs,\n      {\n        kind: TKind;\n        namespace: TNamespace;\n        name: TName;\n      }\n    > => {\n      if (!Array.isArray(options.output)) {\n        throw new Error(\n          'Cannot override an extension that is not declared using the new format with outputs as an array',\n        );\n      }\n      const newOptions = options as CreateExtensionOptions<\n        TKind,\n        TNamespace,\n        TName,\n        UOutput,\n        TInputs,\n        TConfigSchema,\n        UFactoryOutput\n      >;\n      const overrideNewConfigSchema = overrideOptions.config?.schema;\n\n      const schema = {\n        ...newOptions.config?.schema,\n        ...overrideNewConfigSchema,\n      } as TConfigSchema & TExtensionConfigSchema;\n\n      return createExtension({\n        kind: newOptions.kind,\n        namespace: newOptions.namespace,\n        name: newOptions.name,\n        attachTo: overrideOptions.attachTo ?? newOptions.attachTo,\n        disabled: overrideOptions.disabled ?? newOptions.disabled,\n        inputs: { ...overrideOptions.inputs, ...newOptions.inputs },\n        output: overrideOptions.output ?? newOptions.output,\n        config: Object.keys(schema).length === 0 ? undefined : { schema },\n        factory: ({ node, config, inputs }) => {\n          if (!overrideOptions.factory) {\n            return newOptions.factory({\n              node,\n              config,\n              inputs: inputs as unknown as Expand<\n                ResolvedExtensionInputs<TInputs>\n              >,\n            });\n          }\n          const parentResult = overrideOptions.factory(\n            (innerContext?: {\n              config?: {\n                [key in keyof TConfigSchema]: z.infer<\n                  ReturnType<TConfigSchema[key]>\n                >;\n              };\n              inputs?: ResolveInputValueOverrides<TInputs>;\n            }): ExtensionDataContainer<UOutput> => {\n              return createExtensionDataContainer<UOutput>(\n                newOptions.factory({\n                  node,\n                  config: innerContext?.config ?? config,\n                  inputs: resolveInputOverrides(\n                    newOptions.inputs,\n                    inputs,\n                    innerContext?.inputs,\n                  ) as any, // TODO: Might be able to improve this once legacy inputs are gone\n                }) as Iterable<any>,\n                newOptions.output,\n              );\n            },\n            {\n              node,\n              config,\n              inputs,\n            },\n          );\n\n          const deduplicatedResult = new Map<string, UOverrideFactoryOutput>();\n          for (const item of parentResult) {\n            deduplicatedResult.set(item.id, item);\n          }\n\n          return deduplicatedResult.values() as Iterable<UOverrideFactoryOutput>;\n        },\n      } as CreateExtensionOptions<TKind, TNamespace, TName, AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput, TInputs & TExtraInputs, TConfigSchema & TExtensionConfigSchema, UOverrideFactoryOutput>);\n    },\n  } as InternalExtensionDefinition<\n    TConfig &\n      (string extends keyof TConfigSchema\n        ? {}\n        : {\n            [key in keyof TConfigSchema]: z.infer<\n              ReturnType<TConfigSchema[key]>\n            >;\n          }),\n    TConfigInput &\n      (string extends keyof TConfigSchema\n        ? {}\n        : z.input<\n            z.ZodObject<{\n              [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n            }>\n          >),\n    UOutput,\n    TInputs,\n    {\n      kind: TKind;\n      namespace: TNamespace;\n      name: TName;\n    }\n  >;\n}\n"],"names":[],"mappings":"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"}