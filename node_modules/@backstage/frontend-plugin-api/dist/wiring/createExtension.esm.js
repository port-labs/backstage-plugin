import { createSchemaFromZod } from '../schema/createSchemaFromZod.esm.js';
import { resolveInputOverrides } from './resolveInputOverrides.esm.js';
import { createExtensionDataContainer } from './createExtensionDataContainer.esm.js';

function toInternalExtensionDefinition(overrides) {
  const internal = overrides;
  if (internal.$$type !== "@backstage/ExtensionDefinition") {
    throw new Error(
      `Invalid extension definition instance, bad type '${internal.$$type}'`
    );
  }
  const version = internal.version;
  if (version !== "v1" && version !== "v2") {
    throw new Error(
      `Invalid extension definition instance, bad version '${version}'`
    );
  }
  return internal;
}
function createExtension(options) {
  if ("configSchema" in options && "config" in options) {
    throw new Error(`Cannot provide both configSchema and config.schema`);
  }
  let configSchema;
  if ("configSchema" in options) {
    configSchema = options.configSchema;
  }
  if ("config" in options) {
    const newConfigSchema = options.config?.schema;
    configSchema = newConfigSchema && createSchemaFromZod(
      (innerZ) => innerZ.object(
        Object.fromEntries(
          Object.entries(newConfigSchema).map(([k, v]) => [k, v(innerZ)])
        )
      )
    );
  }
  return {
    $$type: "@backstage/ExtensionDefinition",
    version: Symbol.iterator in options.output ? "v2" : "v1",
    kind: options.kind,
    namespace: options.namespace,
    name: options.name,
    attachTo: options.attachTo,
    disabled: options.disabled ?? false,
    inputs: options.inputs ?? {},
    output: options.output,
    configSchema,
    factory: options.factory,
    toString() {
      const parts = [];
      if (options.kind) {
        parts.push(`kind=${options.kind}`);
      }
      if (options.namespace) {
        parts.push(`namespace=${options.namespace}`);
      }
      if (options.name) {
        parts.push(`name=${options.name}`);
      }
      parts.push(`attachTo=${options.attachTo.id}@${options.attachTo.input}`);
      return `ExtensionDefinition{${parts.join(",")}}`;
    },
    override: (overrideOptions) => {
      if (!Array.isArray(options.output)) {
        throw new Error(
          "Cannot override an extension that is not declared using the new format with outputs as an array"
        );
      }
      const newOptions = options;
      const overrideNewConfigSchema = overrideOptions.config?.schema;
      const schema = {
        ...newOptions.config?.schema,
        ...overrideNewConfigSchema
      };
      return createExtension({
        kind: newOptions.kind,
        namespace: newOptions.namespace,
        name: newOptions.name,
        attachTo: overrideOptions.attachTo ?? newOptions.attachTo,
        disabled: overrideOptions.disabled ?? newOptions.disabled,
        inputs: { ...overrideOptions.inputs, ...newOptions.inputs },
        output: overrideOptions.output ?? newOptions.output,
        config: Object.keys(schema).length === 0 ? void 0 : { schema },
        factory: ({ node, config, inputs }) => {
          if (!overrideOptions.factory) {
            return newOptions.factory({
              node,
              config,
              inputs
            });
          }
          const parentResult = overrideOptions.factory(
            (innerContext) => {
              return createExtensionDataContainer(
                newOptions.factory({
                  node,
                  config: innerContext?.config ?? config,
                  inputs: resolveInputOverrides(
                    newOptions.inputs,
                    inputs,
                    innerContext?.inputs
                  )
                  // TODO: Might be able to improve this once legacy inputs are gone
                }),
                newOptions.output
              );
            },
            {
              node,
              config,
              inputs
            }
          );
          const deduplicatedResult = /* @__PURE__ */ new Map();
          for (const item of parentResult) {
            deduplicatedResult.set(item.id, item);
          }
          return deduplicatedResult.values();
        }
      });
    }
  };
}

export { createExtension, toInternalExtensionDefinition };
//# sourceMappingURL=createExtension.esm.js.map
