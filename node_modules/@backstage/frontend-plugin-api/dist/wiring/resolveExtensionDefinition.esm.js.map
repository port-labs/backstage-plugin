{"version":3,"file":"resolveExtensionDefinition.esm.js","sources":["../../src/wiring/resolveExtensionDefinition.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppNode } from '../apis';\nimport {\n  AnyExtensionDataMap,\n  AnyExtensionInputMap,\n  ExtensionDataValues,\n  ExtensionDefinition,\n  ResolvedExtensionInputs,\n  toInternalExtensionDefinition,\n} from './createExtension';\nimport { PortableSchema } from '../schema';\nimport { ExtensionInput } from './createExtensionInput';\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\n\n/** @public */\nexport interface Extension<TConfig, TConfigInput = TConfig> {\n  $$type: '@backstage/Extension';\n  readonly id: string;\n  readonly attachTo: { id: string; input: string };\n  readonly disabled: boolean;\n  readonly configSchema?: PortableSchema<TConfig, TConfigInput>;\n}\n\n/** @internal */\nexport type InternalExtension<TConfig, TConfigInput> = Extension<\n  TConfig,\n  TConfigInput\n> &\n  (\n    | {\n        readonly version: 'v1';\n        readonly inputs: AnyExtensionInputMap;\n        readonly output: AnyExtensionDataMap;\n        factory(options: {\n          node: AppNode;\n          config: TConfig;\n          inputs: ResolvedExtensionInputs<AnyExtensionInputMap>;\n        }): ExtensionDataValues<any>;\n      }\n    | {\n        readonly version: 'v2';\n        readonly inputs: {\n          [inputName in string]: ExtensionInput<\n            AnyExtensionDataRef,\n            { optional: boolean; singleton: boolean }\n          >;\n        };\n        readonly output: Array<AnyExtensionDataRef>;\n        factory(options: {\n          node: AppNode;\n          config: TConfig;\n          inputs: ResolvedExtensionInputs<{\n            [inputName in string]: ExtensionInput<\n              AnyExtensionDataRef,\n              { optional: boolean; singleton: boolean }\n            >;\n          }>;\n        }): Iterable<ExtensionDataValue<any, any>>;\n      }\n  );\n\n/** @internal */\nexport function toInternalExtension<TConfig, TConfigInput>(\n  overrides: Extension<TConfig, TConfigInput>,\n): InternalExtension<TConfig, TConfigInput> {\n  const internal = overrides as InternalExtension<TConfig, TConfigInput>;\n  if (internal.$$type !== '@backstage/Extension') {\n    throw new Error(\n      `Invalid extension instance, bad type '${internal.$$type}'`,\n    );\n  }\n  const version = internal.version;\n  if (version !== 'v1' && version !== 'v2') {\n    throw new Error(`Invalid extension instance, bad version '${version}'`);\n  }\n  return internal;\n}\n\n/** @ignore */\nexport type ResolveExtensionId<\n  TExtension extends ExtensionDefinition<any>,\n  TDefaultNamespace extends string | undefined,\n> = TExtension extends ExtensionDefinition<\n  any,\n  any,\n  any,\n  any,\n  {\n    kind: infer IKind extends string | undefined;\n    namespace: infer INamespace extends string | undefined;\n    name: infer IName extends string | undefined;\n  }\n>\n  ? [string | undefined] extends [IKind | INamespace | IName]\n    ? never\n    : (\n        (\n          undefined extends TDefaultNamespace ? INamespace : TDefaultNamespace\n        ) extends infer ISelectedNamespace extends string\n          ? undefined extends IName\n            ? ISelectedNamespace\n            : `${ISelectedNamespace}/${IName}`\n          : IName\n      ) extends infer INamePart extends string\n    ? IKind extends string\n      ? `${IKind}:${INamePart}`\n      : INamePart\n    : never\n  : never;\n\n/** @internal */\nexport function resolveExtensionDefinition<TConfig, TConfigInput>(\n  definition: ExtensionDefinition<TConfig, TConfigInput>,\n  context?: { namespace?: string },\n): Extension<TConfig, TConfigInput> {\n  const internalDefinition = toInternalExtensionDefinition(definition);\n  const {\n    name,\n    kind,\n    namespace: _skip1,\n    override: _skip2,\n    ...rest\n  } = internalDefinition;\n  const namespace = internalDefinition.namespace ?? context?.namespace;\n\n  const namePart =\n    name && namespace ? `${namespace}/${name}` : namespace || name;\n  if (!namePart) {\n    throw new Error(\n      `Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${kind} namespace=${namespace} name=${name}`,\n    );\n  }\n\n  const id = kind ? `${kind}:${namePart}` : namePart;\n\n  return {\n    ...rest,\n    $$type: '@backstage/Extension',\n    version: internalDefinition.version,\n    id,\n    toString() {\n      return `Extension{id=${id}}`;\n    },\n  } as InternalExtension<TConfig, TConfigInput>;\n}\n"],"names":[],"mappings":";;AAiIgB,SAAA,0BAAA,CACd,YACA,OACkC,EAAA;AAClC,EAAM,MAAA,kBAAA,GAAqB,8BAA8B,UAAU,CAAA,CAAA;AACnE,EAAM,MAAA;AAAA,IACJ,IAAA;AAAA,IACA,IAAA;AAAA,IACA,SAAW,EAAA,MAAA;AAAA,IACX,QAAU,EAAA,MAAA;AAAA,IACV,GAAG,IAAA;AAAA,GACD,GAAA,kBAAA,CAAA;AACJ,EAAM,MAAA,SAAA,GAAY,kBAAmB,CAAA,SAAA,IAAa,OAAS,EAAA,SAAA,CAAA;AAE3D,EAAM,MAAA,QAAA,GACJ,QAAQ,SAAY,GAAA,CAAA,EAAG,SAAS,CAAI,CAAA,EAAA,IAAI,KAAK,SAAa,IAAA,IAAA,CAAA;AAC5D,EAAA,IAAI,CAAC,QAAU,EAAA;AACb,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAuG,oGAAA,EAAA,IAAI,CAAc,WAAA,EAAA,SAAS,SAAS,IAAI,CAAA,CAAA;AAAA,KACjJ,CAAA;AAAA,GACF;AAEA,EAAA,MAAM,KAAK,IAAO,GAAA,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,QAAQ,CAAK,CAAA,GAAA,QAAA,CAAA;AAE1C,EAAO,OAAA;AAAA,IACL,GAAG,IAAA;AAAA,IACH,MAAQ,EAAA,sBAAA;AAAA,IACR,SAAS,kBAAmB,CAAA,OAAA;AAAA,IAC5B,EAAA;AAAA,IACA,QAAW,GAAA;AACT,MAAA,OAAO,gBAAgB,EAAE,CAAA,CAAA,CAAA,CAAA;AAAA,KAC3B;AAAA,GACF,CAAA;AACF;;;;"}