{"version":3,"file":"createExtensionBlueprint.esm.js","sources":["../../src/wiring/createExtensionBlueprint.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppNode } from '../apis';\nimport { Expand } from '../types';\nimport {\n  CreateExtensionOptions,\n  ExtensionDefinition,\n  ResolvedExtensionInputs,\n  VerifyExtensionFactoryOutput,\n  createExtension,\n} from './createExtension';\nimport { z } from 'zod';\nimport { ExtensionInput } from './createExtensionInput';\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\nimport {\n  ExtensionDataContainer,\n  createExtensionDataContainer,\n} from './createExtensionDataContainer';\nimport {\n  ResolveInputValueOverrides,\n  resolveInputOverrides,\n} from './resolveInputOverrides';\n\n/**\n * @public\n */\nexport type CreateExtensionBlueprintOptions<\n  TKind extends string,\n  TNamespace extends string | undefined,\n  TName extends string | undefined,\n  TParams,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  TDataRefs extends { [name in string]: AnyExtensionDataRef },\n> = {\n  kind: TKind;\n  namespace?: TNamespace;\n  attachTo: { id: string; input: string };\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: Array<UOutput>;\n  name?: TName;\n  config?: {\n    schema: TConfigSchema;\n  };\n  factory(\n    params: TParams,\n    context: {\n      node: AppNode;\n      config: {\n        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n      };\n      inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n    },\n  ): Iterable<UFactoryOutput>;\n\n  dataRefs?: TDataRefs;\n} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;\n\n/**\n * @public\n */\nexport interface ExtensionBlueprint<\n  TIdParts extends {\n    kind: string;\n    namespace?: string;\n    name?: string;\n  },\n  TParams,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfig extends { [key in string]: unknown },\n  TConfigInput extends { [key in string]: unknown },\n  TDataRefs extends { [name in string]: AnyExtensionDataRef },\n> {\n  dataRefs: TDataRefs;\n\n  make<\n    TNewNamespace extends string | undefined,\n    TNewName extends string | undefined,\n  >(args: {\n    namespace?: TNewNamespace;\n    name?: TNewName;\n    attachTo?: { id: string; input: string };\n    disabled?: boolean;\n    params: TParams;\n  }): ExtensionDefinition<\n    TConfig,\n    TConfigInput,\n    UOutput,\n    TInputs,\n    {\n      kind: TIdParts['kind'];\n      namespace: string | undefined extends TNewNamespace\n        ? TIdParts['namespace']\n        : TNewNamespace;\n      name: string | undefined extends TNewName ? TIdParts['name'] : TNewName;\n    }\n  >;\n\n  /**\n   * Creates a new extension from the blueprint.\n   *\n   * You must either pass `params` directly, or define a `factory` that can\n   * optionally call the original factory with the same params.\n   */\n  makeWithOverrides<\n    TNewNamespace extends string | undefined,\n    TNewName extends string | undefined,\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends AnyExtensionDataRef,\n    TExtraInputs extends {\n      [inputName in string]: ExtensionInput<\n        AnyExtensionDataRef,\n        { optional: boolean; singleton: boolean }\n      >;\n    },\n  >(args: {\n    namespace?: TNewNamespace;\n    name?: TNewName;\n    attachTo?: { id: string; input: string };\n    disabled?: boolean;\n    inputs?: TExtraInputs & {\n      [KName in keyof TInputs]?: `Error: Input '${KName &\n        string}' is already defined in parent definition`;\n    };\n    output?: Array<UNewOutput>;\n    config?: {\n      schema: TExtensionConfigSchema & {\n        [KName in keyof TConfig]?: `Error: Config key '${KName &\n          string}' is already defined in parent schema`;\n      };\n    };\n    factory(\n      originalFactory: (\n        params: TParams,\n        context?: {\n          config?: TConfig;\n          inputs?: ResolveInputValueOverrides<TInputs>;\n        },\n      ) => ExtensionDataContainer<UOutput>,\n      context: {\n        node: AppNode;\n        config: TConfig & {\n          [key in keyof TExtensionConfigSchema]: z.infer<\n            ReturnType<TExtensionConfigSchema[key]>\n          >;\n        };\n        inputs: Expand<ResolvedExtensionInputs<TInputs & TExtraInputs>>;\n      },\n    ): Iterable<UFactoryOutput> &\n      VerifyExtensionFactoryOutput<\n        AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput,\n        UFactoryOutput\n      >;\n  }): ExtensionDefinition<\n    {\n      [key in keyof TExtensionConfigSchema]: z.infer<\n        ReturnType<TExtensionConfigSchema[key]>\n      >;\n    } & TConfig,\n    z.input<\n      z.ZodObject<{\n        [key in keyof TExtensionConfigSchema]: ReturnType<\n          TExtensionConfigSchema[key]\n        >;\n      }>\n    > &\n      TConfigInput,\n    AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput,\n    TInputs & TExtraInputs,\n    {\n      kind: TIdParts['kind'];\n      namespace: string | undefined extends TNewNamespace\n        ? TIdParts['namespace']\n        : TNewNamespace;\n      name: string | undefined extends TNewName ? TIdParts['name'] : TNewName;\n    }\n  >;\n}\n\n/**\n * @internal\n */\nclass ExtensionBlueprintImpl<\n  TKind extends string,\n  TNamespace extends string | undefined,\n  TName extends string | undefined,\n  TParams,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType },\n  TDataRefs extends { [name in string]: AnyExtensionDataRef },\n> {\n  constructor(\n    private readonly options: CreateExtensionBlueprintOptions<\n      TKind,\n      TNamespace,\n      TName,\n      TParams,\n      UOutput,\n      TInputs,\n      TConfigSchema,\n      any,\n      TDataRefs\n    >,\n  ) {\n    this.dataRefs = options.dataRefs!;\n  }\n\n  dataRefs: TDataRefs;\n\n  public makeWithOverrides<\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends AnyExtensionDataRef,\n    TExtraInputs extends {\n      [inputName in string]: ExtensionInput<\n        AnyExtensionDataRef,\n        { optional: boolean; singleton: boolean }\n      >;\n    },\n    TNewNamespace extends string | undefined = undefined,\n    TNewName extends string | undefined = undefined,\n  >(args: {\n    namespace?: TNewNamespace;\n    name?: TNewName;\n    attachTo?: { id: string; input: string };\n    disabled?: boolean;\n    inputs?: TExtraInputs;\n    output?: Array<UNewOutput>;\n    config?: {\n      schema: TExtensionConfigSchema;\n    };\n    factory(\n      originalFactory: (\n        params: TParams,\n        context?: {\n          config?: {\n            [key in keyof TConfigSchema]: z.infer<\n              ReturnType<TConfigSchema[key]>\n            >;\n          };\n          inputs?: ResolveInputValueOverrides<TInputs>;\n        },\n      ) => ExtensionDataContainer<UOutput>,\n      context: {\n        node: AppNode;\n        config: {\n          [key in keyof TExtensionConfigSchema]: z.infer<\n            ReturnType<TExtensionConfigSchema[key]>\n          >;\n        } & {\n          [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n        };\n        inputs: Expand<ResolvedExtensionInputs<TInputs & TExtraInputs>>;\n      },\n    ): Iterable<UFactoryOutput>;\n  }): ExtensionDefinition<\n    {\n      [key in keyof TExtensionConfigSchema]: z.infer<\n        ReturnType<TExtensionConfigSchema[key]>\n      >;\n    } & {\n      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n    },\n    z.input<\n      z.ZodObject<\n        {\n          [key in keyof TExtensionConfigSchema]: ReturnType<\n            TExtensionConfigSchema[key]\n          >;\n        } & {\n          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n        }\n      >\n    >\n  > {\n    const schema = {\n      ...this.options.config?.schema,\n      ...args.config?.schema,\n    } as TConfigSchema & TExtensionConfigSchema;\n\n    return createExtension({\n      kind: this.options.kind,\n      namespace: args.namespace ?? this.options.namespace,\n      name: args.name ?? this.options.name,\n      attachTo: args.attachTo ?? this.options.attachTo,\n      disabled: args.disabled ?? this.options.disabled,\n      inputs: { ...args.inputs, ...this.options.inputs },\n      output: args.output ?? this.options.output,\n      config: Object.keys(schema).length === 0 ? undefined : { schema },\n      factory: ({ node, config, inputs }) => {\n        return args.factory(\n          (\n            innerParams: TParams,\n            innerContext?: {\n              config?: {\n                [key in keyof TConfigSchema]: z.infer<\n                  ReturnType<TConfigSchema[key]>\n                >;\n              };\n              inputs?: ResolveInputValueOverrides;\n            },\n          ): ExtensionDataContainer<UOutput> => {\n            return createExtensionDataContainer<UOutput>(\n              this.options.factory(innerParams, {\n                node,\n                config: innerContext?.config ?? config,\n                inputs: resolveInputOverrides(\n                  this.options.inputs,\n                  inputs,\n                  innerContext?.inputs,\n                ) as any, // TODO: Might be able to improve this once legacy inputs are gone\n              }),\n              this.options.output,\n            );\n          },\n          {\n            node,\n            config,\n            inputs,\n          },\n        );\n      },\n    } as CreateExtensionOptions<TKind, string | undefined extends TNewNamespace ? TNamespace : TNewNamespace, string | undefined extends TNewName ? TName : TNewName, AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput, TInputs & TExtraInputs, TConfigSchema & TExtensionConfigSchema, UFactoryOutput>);\n  }\n\n  public make<\n    TNewNamespace extends string | undefined = undefined,\n    TNewName extends string | undefined = undefined,\n  >(args: {\n    namespace?: TNewNamespace;\n    name?: TNewName;\n    attachTo?: { id: string; input: string };\n    disabled?: boolean;\n    params: TParams;\n  }): ExtensionDefinition<\n    {\n      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n    },\n    z.input<\n      z.ZodObject<{\n        [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n      }>\n    >\n  > {\n    return createExtension({\n      kind: this.options.kind,\n      namespace: args.namespace ?? this.options.namespace,\n      name: args.name ?? this.options.name,\n      attachTo: args.attachTo ?? this.options.attachTo,\n      disabled: args.disabled ?? this.options.disabled,\n      inputs: this.options.inputs,\n      output: this.options.output,\n      config: this.options.config,\n      factory: ctx => this.options.factory(args.params, ctx),\n    } as CreateExtensionOptions<TKind, string | undefined extends TNewNamespace ? TNamespace : TNewNamespace, string | undefined extends TNewName ? TName : TNewName, UOutput, TInputs, TConfigSchema, any>);\n  }\n}\n\n/**\n * A simpler replacement for wrapping up `createExtension` inside a kind or type. This allows for a cleaner API for creating\n * types and instances of those types.\n *\n * @public\n */\nexport function createExtensionBlueprint<\n  TParams,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  TKind extends string,\n  TNamespace extends string | undefined = undefined,\n  TName extends string | undefined = undefined,\n  TDataRefs extends { [name in string]: AnyExtensionDataRef } = never,\n>(\n  options: CreateExtensionBlueprintOptions<\n    TKind,\n    TNamespace,\n    TName,\n    TParams,\n    UOutput,\n    TInputs,\n    TConfigSchema,\n    UFactoryOutput,\n    TDataRefs\n  >,\n): ExtensionBlueprint<\n  {\n    kind: TKind;\n    namespace: TNamespace;\n    name: TName;\n  },\n  TParams,\n  UOutput,\n  string extends keyof TInputs ? {} : TInputs,\n  string extends keyof TConfigSchema\n    ? {}\n    : { [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>> },\n  string extends keyof TConfigSchema\n    ? {}\n    : z.input<\n        z.ZodObject<{\n          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n        }>\n      >,\n  TDataRefs\n> {\n  return new ExtensionBlueprintImpl(options) as ExtensionBlueprint<\n    {\n      kind: TKind;\n      namespace: TNamespace;\n      name: TName;\n    },\n    TParams,\n    UOutput,\n    string extends keyof TInputs ? {} : TInputs,\n    string extends keyof TConfigSchema\n      ? {}\n      : {\n          [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n        },\n    string extends keyof TConfigSchema\n      ? {}\n      : z.input<\n          z.ZodObject<{\n            [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n          }>\n        >,\n    TDataRefs\n  >;\n}\n"],"names":[],"mappings":"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"}