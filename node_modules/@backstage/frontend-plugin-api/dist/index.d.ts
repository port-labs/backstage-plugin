/// <reference types="react" />
import * as React from 'react';
import React__default, { ReactNode, JSX as JSX$1, ComponentType, PropsWithChildren } from 'react';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { ApiRef, AnyApiFactory, IconComponent as IconComponent$1, SignInPageProps, AppTheme, AnyApiRef } from '@backstage/core-plugin-api';
export { AlertApi, AlertMessage, AnyApiFactory, AnyApiRef, ApiFactory, ApiHolder, ApiRef, ApiRefConfig, AppTheme, AppThemeApi, AuthProviderInfo, AuthRequestOptions, BackstageIdentityApi, BackstageIdentityResponse, BackstageUserIdentity, ConfigApi, DiscoveryApi, ErrorApi, ErrorApiError, ErrorApiErrorContext, FeatureFlag, FeatureFlagState, FeatureFlagsApi, FeatureFlagsSaveOptions, FetchApi, IdentityApi, OAuthApi, OAuthRequestApi, OAuthRequester, OAuthRequesterOptions, OAuthScope, OpenIdConnectApi, PendingOAuthRequest, ProfileInfo, ProfileInfoApi, SessionApi, SessionState, StorageApi, StorageValueSnapshot, TypesToApiRefs, alertApiRef, appThemeApiRef, atlassianAuthApiRef, bitbucketAuthApiRef, bitbucketServerAuthApiRef, configApiRef, createApiFactory, createApiRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, fetchApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauthRequestApiRef, oktaAuthApiRef, oneloginAuthApiRef, storageApiRef, useApi, useApiHolder, vmwareCloudAuthApiRef, withApis } from '@backstage/core-plugin-api';
import { z, ZodSchema, ZodTypeDef } from 'zod';
import { JsonObject } from '@backstage/types';
import { TranslationResource, TranslationMessages } from '@backstage/core-plugin-api/alpha';
export { TranslationMessages, TranslationMessagesOptions, TranslationRef, TranslationRefOptions, TranslationResource, TranslationResourceOptions, createTranslationMessages, createTranslationRef, createTranslationResource, useTranslationRef } from '@backstage/core-plugin-api/alpha';

/**
 * Common analytics context attributes.
 *
 * @public
 */
type CommonAnalyticsContext = {
    /**
     * The nearest known parent plugin where the event was captured.
     */
    pluginId: string;
    /**
     * The nearest known parent extension where the event was captured.
     */
    extensionId: string;
};
/**
 * Analytics context envelope.
 *
 * @public
 */
type AnalyticsContextValue = CommonAnalyticsContext & {
    [param in string]: string | boolean | number | undefined;
};

/**
 * Provides components in the child react tree an Analytics Context, ensuring
 * all analytics events captured within the context have relevant attributes.
 *
 * @remarks
 *
 * Analytics contexts are additive, meaning the context ultimately emitted with
 * an event is the combination of all contexts in the parent tree.
 *
 * @public
 */
declare const AnalyticsContext: (options: {
    attributes: Partial<AnalyticsContextValue>;
    children: ReactNode;
}) => React__default.JSX.Element;

/**
 * Catch-all type for route params.
 *
 * @public
 */
type AnyRouteRefParams = {
    [param in string]: string;
} | undefined;

/**
 * Absolute route reference.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface RouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/RouteRef';
    readonly T: TParams;
}
/**
 * Create a {@link RouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(config?: {
    /** A list of parameter names that the path that this route ref is bound to must contain */
    readonly params: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
}): RouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/**
 * Descriptor of a route relative to an absolute {@link RouteRef}.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface SubRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/SubRouteRef';
    readonly T: TParams;
    readonly path: string;
}
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
/**
 * This utility type helps us infer a Param object type from a string path
 * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`
 * @ignore
 */
type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with an optional params type into a params object.
 * @ignore
 */
type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyRouteRefParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Convert empty params to undefined.
 * @ignore
 */
type TrimEmptyParams<Params extends {
    [param in string]: string;
}> = keyof Params extends never ? undefined : Params;
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 *
 * @ignore
 */
type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyRouteRefParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>> : never;
/**
 * Create a {@link SubRouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createSubRouteRef<Path extends string, ParentParams extends AnyRouteRefParams = never>(config: {
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

/**
 * Route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface ExternalRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/ExternalRouteRef';
    readonly T: TParams;
}
/**
 * Creates a route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @param options - Description of the route reference to be created.
 * @public
 */
declare function createExternalRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(options?: {
    /**
     * The parameters that will be provided to the external route reference.
     */
    readonly params?: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
    /**
     * The route (typically in another plugin) that this should map to by default.
     *
     * The string is expected to be on the standard `<plugin id>.<route id>` form,
     * for example `techdocs.docRoot`.
     */
    defaultTarget?: string;
}): ExternalRouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`, or `undefined` if the route is not available.
 * @public
 */
declare function useRouteRef<TParams extends AnyRouteRefParams>(routeRef: RouteRef<TParams> | SubRouteRef<TParams> | ExternalRouteRef<TParams>): RouteFunc<TParams> | undefined;

/**
 * React hook for retrieving dynamic params from the current URL.
 * @param _routeRef - Ref of the current route.
 * @public
 */
declare function useRouteRefParams<Params extends AnyRouteRefParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

/** @public */
type ExtensionDataValue<TData, TId extends string> = {
    readonly $$type: '@backstage/ExtensionDataValue';
    readonly id: TId;
    readonly value: TData;
};
/** @public */
type ExtensionDataRef<TData, TId extends string = string, TConfig extends {
    optional?: true;
} = {}> = {
    readonly $$type: '@backstage/ExtensionDataRef';
    readonly id: TId;
    readonly T: TData;
    readonly config: TConfig;
};
/** @public */
type ExtensionDataRefToValue<TDataRef extends AnyExtensionDataRef> = TDataRef extends ExtensionDataRef<infer IData, infer IId, any> ? ExtensionDataValue<IData, IId> : never;
/** @public */
type AnyExtensionDataRef = ExtensionDataRef<unknown, string, {
    optional?: true;
}>;
/** @public */
interface ConfigurableExtensionDataRef<TData, TId extends string, TConfig extends {
    optional?: true;
} = {}> extends ExtensionDataRef<TData, TId, TConfig> {
    optional(): ConfigurableExtensionDataRef<TData, TId, TConfig & {
        optional: true;
    }>;
    (t: TData): ExtensionDataValue<TData, TId>;
}
/**
 * @public
 * @deprecated Use the following form instead: `createExtensionDataRef<Type>().with({ id: 'core.foo' })`
 */
declare function createExtensionDataRef<TData>(id: string): ConfigurableExtensionDataRef<TData, string>;
/** @public */
declare function createExtensionDataRef<TData>(): {
    with<TId extends string>(options: {
        id: TId;
    }): ConfigurableExtensionDataRef<TData, TId>;
};

/** @public */
declare const coreExtensionData: {
    reactElement: ConfigurableExtensionDataRef<JSX$1.Element, "core.reactElement", {}>;
    routePath: ConfigurableExtensionDataRef<string, "core.routing.path", {}>;
    routeRef: ConfigurableExtensionDataRef<RouteRef<AnyRouteRefParams>, "core.routing.ref", {}>;
};

/** @public */
type PortableSchema<TOutput, TInput = TOutput> = {
    parse: (input: TInput) => TOutput;
    schema: JsonObject;
};

/**
 * @public
 * @deprecated Use the `config.schema` option of `createExtension` instead, or use `createExtensionBlueprint`.
 */
declare function createSchemaFromZod<TOutput, TInput>(schemaCreator: (zImpl: typeof z) => ZodSchema<TOutput, ZodTypeDef, TInput>): PortableSchema<TOutput, TInput>;

/**
 * Utility type to expand type aliases into their equivalent type.
 * @ignore
 */
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
/** @public */
type CoreProgressProps = {};
/** @public */
type CoreNotFoundErrorPageProps = {
    children?: ReactNode;
};
/** @public */
type CoreErrorBoundaryFallbackProps = {
    plugin?: BackstagePlugin;
    error: Error;
    resetError: () => void;
};

/** @public */
interface ExtensionInput<TExtensionData extends ExtensionDataRef<unknown, string, {
    optional?: true;
}>, TConfig extends {
    singleton: boolean;
    optional: boolean;
}> {
    $$type: '@backstage/ExtensionInput';
    extensionData: Array<TExtensionData>;
    config: TConfig;
}
/**
 * @public
 * @deprecated This type will be removed. Use `ExtensionInput` instead.
 */
interface LegacyExtensionInput<TExtensionDataMap extends AnyExtensionDataMap, TConfig extends {
    singleton: boolean;
    optional: boolean;
}> {
    $$type: '@backstage/ExtensionInput';
    extensionData: TExtensionDataMap;
    config: TConfig;
}
/**
 * @public
 * @deprecated Use the following form instead: `createExtensionInput([dataRef1, dataRef2])`
 */
declare function createExtensionInput<TExtensionDataMap extends AnyExtensionDataMap, TConfig extends {
    singleton?: boolean;
    optional?: boolean;
}>(extensionData: TExtensionDataMap, config?: TConfig): LegacyExtensionInput<TExtensionDataMap, {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
}>;
/** @public */
declare function createExtensionInput<UExtensionData extends ExtensionDataRef<unknown, string, {
    optional?: true;
}>, TConfig extends {
    singleton?: boolean;
    optional?: boolean;
}>(extensionData: Array<UExtensionData>, config?: TConfig): ExtensionInput<UExtensionData, {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
}>;

/** @public */
type ResolveInputValueOverrides<TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
} = {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}> = Expand<{
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<any, {
        optional: infer IOptional extends boolean;
        singleton: boolean;
    }> ? IOptional extends true ? never : KName : never]: TInputs[KName] extends ExtensionInput<infer IDataRefs, {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
    }> ? ISingleton extends true ? Iterable<ExtensionDataRefToValue<IDataRefs>> : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>> : never;
} & {
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<any, {
        optional: infer IOptional extends boolean;
        singleton: boolean;
    }> ? IOptional extends true ? KName : never : never]?: TInputs[KName] extends ExtensionInput<infer IDataRefs, {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
    }> ? ISingleton extends true ? Iterable<ExtensionDataRefToValue<IDataRefs>> : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>> : never;
}>;

/** @public */
type ExtensionDataContainer<UExtensionData extends AnyExtensionDataRef> = Iterable<UExtensionData extends ExtensionDataRef<infer IData, infer IId, infer IConfig> ? IConfig['optional'] extends true ? never : ExtensionDataValue<IData, IId> : never> & {
    get<TId extends UExtensionData['id']>(ref: ExtensionDataRef<any, TId, any>): UExtensionData extends ExtensionDataRef<infer IData, TId, infer IConfig> ? IConfig['optional'] extends true ? IData | undefined : IData : never;
};

/**
 * @public
 * @deprecated Extension data maps will be removed.
 */
type AnyExtensionDataMap = {
    [name in string]: AnyExtensionDataRef;
};
/**
 * @public
 * @deprecated This type will be removed.
 */
type AnyExtensionInputMap = {
    [inputName in string]: LegacyExtensionInput<AnyExtensionDataMap, {
        optional: boolean;
        singleton: boolean;
    }>;
};
/**
 * Converts an extension data map into the matching concrete data values type.
 * @public
 * @deprecated Extension data maps will be removed.
 */
type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {
    [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
        optional: true;
    } ? never : DataName]: TExtensionData[DataName]['T'];
} & {
    [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
        optional: true;
    } ? DataName : never]?: TExtensionData[DataName]['T'];
};
/**
 * Convert a single extension input into a matching resolved input.
 * @public
 */
type ResolvedExtensionInput<TExtensionInput extends ExtensionInput<any, any>> = TExtensionInput['extensionData'] extends Array<AnyExtensionDataRef> ? {
    node: AppNode;
} & ExtensionDataContainer<TExtensionInput['extensionData'][number]> : TExtensionInput['extensionData'] extends AnyExtensionDataMap ? {
    node: AppNode;
    output: ExtensionDataValues<TExtensionInput['extensionData']>;
} : never;
/**
 * Converts an extension input map into a matching collection of resolved inputs.
 * @public
 */
type ResolvedExtensionInputs<TInputs extends {
    [name in string]: ExtensionInput<any, any> | LegacyExtensionInput<any, any>;
}> = {
    [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton'] ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>> : false extends TInputs[InputName]['config']['optional'] ? Expand<ResolvedExtensionInput<TInputs[InputName]>> : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;
};
/**
 * @public
 * @deprecated This way of structuring the options is deprecated, this type will be removed in the future
 */
interface LegacyCreateExtensionOptions<TOutput extends AnyExtensionDataMap, TInputs extends AnyExtensionInputMap, TConfig, TConfigInput> {
    kind?: string;
    namespace?: string;
    name?: string;
    attachTo: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    output: TOutput;
    configSchema?: PortableSchema<TConfig, TConfigInput>;
    factory(context: {
        node: AppNode;
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Expand<ExtensionDataValues<TOutput>>;
}
type ToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type PopUnion<U> = ToIntersection<U extends any ? () => U : never> extends () => infer R ? [rest: Exclude<U, R>, next: R] : undefined;
/** @ignore */
type JoinStringUnion<U, TDiv extends string = ', ', TResult extends string = ''> = PopUnion<U> extends [infer IRest extends string, infer INext extends string] ? TResult extends '' ? JoinStringUnion<IRest, TDiv, INext> : JoinStringUnion<IRest, TDiv, `${TResult}${TDiv}${INext}`> : TResult;
/** @ignore */
type VerifyExtensionFactoryOutput<UDeclaredOutput extends AnyExtensionDataRef, UFactoryOutput extends ExtensionDataValue<any, any>> = (UDeclaredOutput extends any ? UDeclaredOutput['config']['optional'] extends true ? never : UDeclaredOutput['id'] : never) extends infer IRequiredOutputIds ? [IRequiredOutputIds] extends [UFactoryOutput['id']] ? [UFactoryOutput['id']] extends [UDeclaredOutput['id']] ? {} : `Error: The extension factory has undeclared output(s): ${JoinStringUnion<Exclude<UFactoryOutput['id'], UDeclaredOutput['id']>>}` : `Error: The extension factory is missing the following output(s): ${JoinStringUnion<Exclude<IRequiredOutputIds, UFactoryOutput['id']>>}` : never;
/** @public */
type CreateExtensionOptions<TKind extends string | undefined, TNamespace extends string | undefined, TName extends string | undefined, UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>> = {
    kind?: TKind;
    namespace?: TNamespace;
    name?: TName;
    attachTo: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    output: Array<UOutput>;
    config?: {
        schema: TConfigSchema;
    };
    factory(context: {
        node: AppNode;
        config: {
            [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
        };
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Iterable<UFactoryOutput>;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;
/** @public */
interface ExtensionDefinition<TConfig, TConfigInput = TConfig, UOutput extends AnyExtensionDataRef = AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
} = {}, TIdParts extends {
    kind?: string;
    namespace?: string;
    name?: string;
} = {
    kind?: string;
    namespace?: string;
    name?: string;
}> {
    $$type: '@backstage/ExtensionDefinition';
    readonly kind?: TIdParts['kind'];
    readonly namespace?: TIdParts['namespace'];
    readonly name?: TIdParts['name'];
    readonly attachTo: {
        id: string;
        input: string;
    };
    readonly disabled: boolean;
    readonly configSchema?: PortableSchema<TConfig, TConfigInput>;
    override<TExtensionConfigSchema extends {
        [key in string]: (zImpl: typeof z) => z.ZodType;
    }, UFactoryOutput extends ExtensionDataValue<any, any>, UNewOutput extends AnyExtensionDataRef, TExtraInputs extends {
        [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    }>(args: {
        attachTo?: {
            id: string;
            input: string;
        };
        disabled?: boolean;
        inputs?: TExtraInputs & {
            [KName in keyof TInputs]?: `Error: Input '${KName & string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
            schema: TExtensionConfigSchema & {
                [KName in keyof TConfig]?: `Error: Config key '${KName & string}' is already defined in parent schema`;
            };
        };
        factory(originalFactory: (context?: {
            config?: TConfig;
            inputs?: ResolveInputValueOverrides<TInputs>;
        }) => ExtensionDataContainer<UOutput>, context: {
            node: AppNode;
            config: TConfig & {
                [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
            };
            inputs: Expand<ResolvedExtensionInputs<TInputs & TExtraInputs>>;
        }): Iterable<UFactoryOutput>;
    } & VerifyExtensionFactoryOutput<AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput, UFactoryOutput>): ExtensionDefinition<{
        [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
    } & TConfig, z.input<z.ZodObject<{
        [key in keyof TExtensionConfigSchema]: ReturnType<TExtensionConfigSchema[key]>;
    }>> & TConfigInput, AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput, TInputs & TExtraInputs, TIdParts>;
}
/** @public */
declare function createExtension<UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, const TKind extends string | undefined = undefined, const TNamespace extends string | undefined = undefined, const TName extends string | undefined = undefined>(options: CreateExtensionOptions<TKind, TNamespace, TName, UOutput, TInputs, TConfigSchema, UFactoryOutput>): ExtensionDefinition<{
    [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
}, z.input<z.ZodObject<{
    [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
}>>, UOutput, TInputs, {
    kind: string | undefined extends TKind ? undefined : TKind;
    namespace: string | undefined extends TNamespace ? undefined : TNamespace;
    name: string | undefined extends TName ? undefined : TName;
}>;
/**
 * @public
 * @deprecated - use the array format of `output` instead, see TODO-doc-link
 */
declare function createExtension<TOutput extends AnyExtensionDataMap, TInputs extends AnyExtensionInputMap, TConfig, TConfigInput>(options: LegacyCreateExtensionOptions<TOutput, TInputs, TConfig, TConfigInput>): ExtensionDefinition<TConfig, TConfigInput, never, never>;

/** @public */
interface Extension<TConfig, TConfigInput = TConfig> {
    $$type: '@backstage/Extension';
    readonly id: string;
    readonly attachTo: {
        id: string;
        input: string;
    };
    readonly disabled: boolean;
    readonly configSchema?: PortableSchema<TConfig, TConfigInput>;
}
/** @ignore */
type ResolveExtensionId<TExtension extends ExtensionDefinition<any>, TDefaultNamespace extends string | undefined> = TExtension extends ExtensionDefinition<any, any, any, any, {
    kind: infer IKind extends string | undefined;
    namespace: infer INamespace extends string | undefined;
    name: infer IName extends string | undefined;
}> ? [string | undefined] extends [IKind | INamespace | IName] ? never : ((undefined extends TDefaultNamespace ? INamespace : TDefaultNamespace) extends infer ISelectedNamespace extends string ? undefined extends IName ? ISelectedNamespace : `${ISelectedNamespace}/${IName}` : IName) extends infer INamePart extends string ? IKind extends string ? `${IKind}:${INamePart}` : INamePart : never : never;

/**
 * Feature flag configuration.
 *
 * @public
 */
type FeatureFlagConfig = {
    /** Feature flag name */
    name: string;
};
/** @public */
type AnyRoutes = {
    [name in string]: RouteRef | SubRouteRef;
};
/** @public */
type AnyExternalRoutes = {
    [name in string]: ExternalRouteRef;
};
/** @public */
interface BackstagePlugin<TRoutes extends AnyRoutes = AnyRoutes, TExternalRoutes extends AnyExternalRoutes = AnyExternalRoutes, TExtensionMap extends {
    [id in string]: ExtensionDefinition<any, any>;
} = {}> {
    readonly $$type: '@backstage/BackstagePlugin';
    readonly id: string;
    readonly routes: TRoutes;
    readonly externalRoutes: TExternalRoutes;
    getExtension<TId extends keyof TExtensionMap>(id: TId): TExtensionMap[TId];
    withOverrides(options: {
        extensions: Array<ExtensionDefinition<any, any>>;
    }): BackstagePlugin<TRoutes, TExternalRoutes, TExtensionMap>;
}
/** @public */
interface ExtensionOverrides {
    readonly $$type: '@backstage/ExtensionOverrides';
}
/** @public */
type FrontendFeature = BackstagePlugin | ExtensionOverrides;

/** @public */
interface PluginOptions<TId extends string, TRoutes extends AnyRoutes, TExternalRoutes extends AnyExternalRoutes, TExtensions extends readonly ExtensionDefinition<any, any>[]> {
    id: TId;
    routes?: TRoutes;
    externalRoutes?: TExternalRoutes;
    extensions?: TExtensions;
    featureFlags?: FeatureFlagConfig[];
}
/** @public */
declare function createFrontendPlugin<TId extends string, TRoutes extends AnyRoutes = {}, TExternalRoutes extends AnyExternalRoutes = {}, TExtensions extends readonly ExtensionDefinition<any, any>[] = []>(options: PluginOptions<TId, TRoutes, TExternalRoutes, TExtensions>): BackstagePlugin<TRoutes, TExternalRoutes, {
    [KExtension in TExtensions[number] as ResolveExtensionId<KExtension, TId>]: KExtension;
}>;
/**
 * @public
 * @deprecated Use {@link createFrontendPlugin} instead.
 */
declare const createPlugin: typeof createFrontendPlugin;

/** @public */
interface ExtensionOverridesOptions {
    extensions: ExtensionDefinition<any, any>[];
    featureFlags?: FeatureFlagConfig[];
}
/** @public */
declare function createExtensionOverrides(options: ExtensionOverridesOptions): ExtensionOverrides;

/**
 * @public
 */
type CreateExtensionBlueprintOptions<TKind extends string, TNamespace extends string | undefined, TName extends string | undefined, TParams, UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, TDataRefs extends {
    [name in string]: AnyExtensionDataRef;
}> = {
    kind: TKind;
    namespace?: TNamespace;
    attachTo: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    output: Array<UOutput>;
    name?: TName;
    config?: {
        schema: TConfigSchema;
    };
    factory(params: TParams, context: {
        node: AppNode;
        config: {
            [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
        };
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Iterable<UFactoryOutput>;
    dataRefs?: TDataRefs;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;
/**
 * @public
 */
interface ExtensionBlueprint<TIdParts extends {
    kind: string;
    namespace?: string;
    name?: string;
}, TParams, UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfig extends {
    [key in string]: unknown;
}, TConfigInput extends {
    [key in string]: unknown;
}, TDataRefs extends {
    [name in string]: AnyExtensionDataRef;
}> {
    dataRefs: TDataRefs;
    make<TNewNamespace extends string | undefined, TNewName extends string | undefined>(args: {
        namespace?: TNewNamespace;
        name?: TNewName;
        attachTo?: {
            id: string;
            input: string;
        };
        disabled?: boolean;
        params: TParams;
    }): ExtensionDefinition<TConfig, TConfigInput, UOutput, TInputs, {
        kind: TIdParts['kind'];
        namespace: string | undefined extends TNewNamespace ? TIdParts['namespace'] : TNewNamespace;
        name: string | undefined extends TNewName ? TIdParts['name'] : TNewName;
    }>;
    /**
     * Creates a new extension from the blueprint.
     *
     * You must either pass `params` directly, or define a `factory` that can
     * optionally call the original factory with the same params.
     */
    makeWithOverrides<TNewNamespace extends string | undefined, TNewName extends string | undefined, TExtensionConfigSchema extends {
        [key in string]: (zImpl: typeof z) => z.ZodType;
    }, UFactoryOutput extends ExtensionDataValue<any, any>, UNewOutput extends AnyExtensionDataRef, TExtraInputs extends {
        [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    }>(args: {
        namespace?: TNewNamespace;
        name?: TNewName;
        attachTo?: {
            id: string;
            input: string;
        };
        disabled?: boolean;
        inputs?: TExtraInputs & {
            [KName in keyof TInputs]?: `Error: Input '${KName & string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
            schema: TExtensionConfigSchema & {
                [KName in keyof TConfig]?: `Error: Config key '${KName & string}' is already defined in parent schema`;
            };
        };
        factory(originalFactory: (params: TParams, context?: {
            config?: TConfig;
            inputs?: ResolveInputValueOverrides<TInputs>;
        }) => ExtensionDataContainer<UOutput>, context: {
            node: AppNode;
            config: TConfig & {
                [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
            };
            inputs: Expand<ResolvedExtensionInputs<TInputs & TExtraInputs>>;
        }): Iterable<UFactoryOutput> & VerifyExtensionFactoryOutput<AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput, UFactoryOutput>;
    }): ExtensionDefinition<{
        [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
    } & TConfig, z.input<z.ZodObject<{
        [key in keyof TExtensionConfigSchema]: ReturnType<TExtensionConfigSchema[key]>;
    }>> & TConfigInput, AnyExtensionDataRef extends UNewOutput ? UOutput : UNewOutput, TInputs & TExtraInputs, {
        kind: TIdParts['kind'];
        namespace: string | undefined extends TNewNamespace ? TIdParts['namespace'] : TNewNamespace;
        name: string | undefined extends TNewName ? TIdParts['name'] : TNewName;
    }>;
}
/**
 * A simpler replacement for wrapping up `createExtension` inside a kind or type. This allows for a cleaner API for creating
 * types and instances of those types.
 *
 * @public
 */
declare function createExtensionBlueprint<TParams, UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, TKind extends string, TNamespace extends string | undefined = undefined, TName extends string | undefined = undefined, TDataRefs extends {
    [name in string]: AnyExtensionDataRef;
} = never>(options: CreateExtensionBlueprintOptions<TKind, TNamespace, TName, TParams, UOutput, TInputs, TConfigSchema, UFactoryOutput, TDataRefs>): ExtensionBlueprint<{
    kind: TKind;
    namespace: TNamespace;
    name: TName;
}, TParams, UOutput, string extends keyof TInputs ? {} : TInputs, string extends keyof TConfigSchema ? {} : {
    [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
}, string extends keyof TConfigSchema ? {} : z.input<z.ZodObject<{
    [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
}>>, TDataRefs>;

/**
 * The specification for this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The specifications for a collection of app nodes is all the information needed
 * to build the tree and instantiate the nodes.
 */
interface AppNodeSpec {
    readonly id: string;
    readonly attachTo: {
        id: string;
        input: string;
    };
    readonly extension: Extension<unknown, unknown>;
    readonly disabled: boolean;
    readonly config?: unknown;
    readonly source?: BackstagePlugin;
}
/**
 * The connections from this {@link AppNode} to other nodes.
 *
 * @public
 * @remarks
 *
 * The app node edges are resolved based on the app node specs, regardless of whether
 * adjacent nodes are disabled or not. If no parent attachment is present or
 */
interface AppNodeEdges {
    readonly attachedTo?: {
        node: AppNode;
        input: string;
    };
    readonly attachments: ReadonlyMap<string, AppNode[]>;
}
/**
 * The instance of this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The app node instance is created when the `factory` function of an extension is called.
 * Instances will only be present for nodes in the app that are connected to the root
 * node and not disabled
 */
interface AppNodeInstance {
    /** Returns a sequence of all extension data refs that were output by this instance */
    getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
    /** Get the output data for a single extension data ref */
    getData<T>(ref: ExtensionDataRef<T>): T | undefined;
}
/**
 * A node in the {@link AppTree}.
 *
 * @public
 */
interface AppNode {
    /** The specification for how this node should be instantiated */
    readonly spec: AppNodeSpec;
    /** The edges from this node to other nodes in the app tree */
    readonly edges: AppNodeEdges;
    /** The instance of this node, if it was instantiated */
    readonly instance?: AppNodeInstance;
}
/**
 * The app tree containing all {@link AppNode}s of the app.
 *
 * @public
 */
interface AppTree {
    /** The root node of the app */
    readonly root: AppNode;
    /** A map of all nodes in the app by ID, including orphaned or disabled nodes */
    readonly nodes: ReadonlyMap<string, AppNode>;
    /** A sequence of all nodes with a parent that is not reachable from the app root node */
    readonly orphans: Iterable<AppNode>;
}
/**
 * The API for interacting with the {@link AppTree}.
 *
 * @public
 */
interface AppTreeApi {
    /**
     * Get the {@link AppTree} for the app.
     */
    getTree(): {
        tree: AppTree;
    };
}
/**
 * The `ApiRef` of {@link AppTreeApi}.
 *
 * @public
 */
declare const appTreeApiRef: _backstage_core_plugin_api.ApiRef<AppTreeApi>;

/** @public */
interface ExtensionBoundaryProps {
    node: AppNode;
    /**
     * This explicitly marks the extension as routable for the purpose of
     * capturing analytics events. If not provided, the extension boundary will be
     * marked as routable if it outputs a routePath.
     */
    routable?: boolean;
    children: ReactNode;
}
/** @public */
declare function ExtensionBoundary(props: ExtensionBoundaryProps): React__default.JSX.Element;
/** @public */
declare namespace ExtensionBoundary {
    function lazy(appNode: AppNode, lazyElement: () => Promise<JSX.Element>): JSX.Element;
}

/** @public */
type ComponentRef<T extends {} = {}> = {
    id: string;
    T: T;
};
/** @public */
declare function createComponentRef<T extends {} = {}>(options: {
    id: string;
}): ComponentRef<T>;

/** @public */
declare const coreComponentRefs: {
    progress: ComponentRef<CoreProgressProps>;
    notFoundErrorPage: ComponentRef<CoreNotFoundErrorPageProps>;
    errorBoundaryFallback: ComponentRef<CoreErrorBoundaryFallbackProps>;
};

/**
 * API for looking up components based on component refs.
 *
 * @public
 */
interface ComponentsApi {
    getComponent<T extends {}>(ref: ComponentRef<T>): ComponentType<T>;
}
/**
 * The `ApiRef` of {@link ComponentsApi}.
 *
 * @public
 */
declare const componentsApiRef: _backstage_core_plugin_api.ApiRef<ComponentsApi>;
/**
 * @public
 * Returns the component associated with the given ref.
 */
declare function useComponentRef<T extends {}>(ref: ComponentRef<T>): ComponentType<T>;

/**
 * IconComponent is the common icon type used throughout Backstage when
 * working with and rendering generic icons, including the app system icons.
 *
 * @remarks
 *
 * The type is based on SvgIcon from Material UI, but both do not what the plugin-api
 * package to have a dependency on Material UI, nor do we want the props to be as broad
 * as the SvgIconProps interface.
 *
 * If you have the need to forward additional props from SvgIconProps, you can
 * open an issue or submit a PR to the main Backstage repo. When doing so please
 * also describe your use-case and reasoning of the addition.
 *
 * @public
 */
type IconComponent = ComponentType<{
    fontSize?: 'large' | 'small' | 'default' | 'inherit';
} | {
    fontSize?: 'medium' | 'large' | 'small' | 'inherit';
}>;

/**
 * API for accessing app icons.
 *
 * @public
 */
interface IconsApi {
    getIcon(key: string): IconComponent | undefined;
    listIconKeys(): string[];
}
/**
 * The `ApiRef` of {@link IconsApi}.
 *
 * @public
 */
declare const iconsApiRef: _backstage_core_plugin_api.ApiRef<IconsApi>;

/**
 * TS magic for handling route parameters.
 *
 * @remarks
 *
 * The extra TS magic here is to require a single params argument if the RouteRef
 * had at least one param defined, but require 0 arguments if there are no params defined.
 * Without this we'd have to pass in empty object to all parameter-less RouteRefs
 * just to make TypeScript happy, or we would have to make the argument optional in
 * which case you might forget to pass it in when it is actually required.
 *
 * @public
 */
type RouteFunc<TParams extends AnyRouteRefParams> = (...[params]: TParams extends undefined ? readonly [] : readonly [params: TParams]) => string;
/**
 * @public
 */
type RouteResolutionApiResolveOptions = {
    /**
     * An absolute path to use as a starting point when resolving the route.
     * If no path is provided the route will be resolved from the root of the app.
     */
    sourcePath?: string;
};
/**
 * @public
 */
interface RouteResolutionApi {
    resolve<TParams extends AnyRouteRefParams>(anyRouteRef: RouteRef<TParams> | SubRouteRef<TParams> | ExternalRouteRef<TParams>, options?: RouteResolutionApiResolveOptions): RouteFunc<TParams> | undefined;
}
/**
 * The `ApiRef` of {@link RouteResolutionApi}.
 *
 * @public
 */
declare const routeResolutionApiRef: _backstage_core_plugin_api.ApiRef<RouteResolutionApi>;

/**
 * Represents an event worth tracking in an analytics system that could inform
 * how users of a Backstage instance are using its features.
 *
 * @public
 */
type AnalyticsEvent = {
    /**
     * A string that identifies the event being tracked by the type of action the
     * event represents. Be careful not to encode extra metadata in this string
     * that should instead be placed in the Analytics Context or attributes.
     * Examples include:
     *
     * - view
     * - click
     * - filter
     * - search
     * - hover
     * - scroll
     */
    action: string;
    /**
     * A string that uniquely identifies the object that the action is being
     * taken on. Examples include:
     *
     * - The path of the page viewed
     * - The url of the link clicked
     * - The value that was filtered by
     * - The text that was searched for
     */
    subject: string;
    /**
     * An optional numeric value relevant to the event that could be aggregated
     * by analytics tools. Examples include:
     *
     * - The index or position of the clicked element in an ordered list
     * - The percentage of an element that has been scrolled through
     * - The amount of time that has elapsed since a fixed point
     * - A satisfaction score on a fixed scale
     */
    value?: number;
    /**
     * Optional, additional attributes (representing dimensions or metrics)
     * specific to the event that could be forwarded on to analytics systems.
     */
    attributes?: AnalyticsEventAttributes;
    /**
     * Contextual metadata relating to where the event was captured and by whom.
     * This could include information about the route, plugin, or extension in
     * which an event was captured.
     */
    context: AnalyticsContextValue;
};
/**
 * A structure allowing other arbitrary metadata to be provided by analytics
 * event emitters.
 *
 * @public
 */
type AnalyticsEventAttributes = {
    [attribute in string]: string | boolean | number;
};
/**
 * Represents a tracker with methods that can be called to track events in a
 * configured analytics service.
 *
 * @public
 */
type AnalyticsTracker = {
    captureEvent: (action: string, subject: string, options?: {
        value?: number;
        attributes?: AnalyticsEventAttributes;
    }) => void;
};
/**
 * The Analytics API is used to track user behavior in a Backstage instance.
 *
 * @remarks
 *
 * To instrument your App or Plugin, retrieve an analytics tracker using the
 * useAnalytics() hook. This will return a pre-configured AnalyticsTracker
 * with relevant methods for instrumentation.
 *
 * @public
 */
type AnalyticsApi = {
    /**
     * Primary event handler responsible for compiling and forwarding events to
     * an analytics system.
     */
    captureEvent(event: AnalyticsEvent): void;
};
/**
 * The API reference of {@link AnalyticsApi}.
 *
 * @public
 */
declare const analyticsApiRef: ApiRef<AnalyticsApi>;

/**
 * Gets a pre-configured analytics tracker.
 *
 * @public
 */
declare function useAnalytics(): AnalyticsTracker;

/**
 * Creates utility API extensions.
 *
 * @public
 */
declare const ApiBlueprint: ExtensionBlueprint<{
    kind: "api";
    namespace: undefined;
    name: undefined;
}, {
    factory: AnyApiFactory;
}, ConfigurableExtensionDataRef<AnyApiFactory, "core.api.factory", {}>, {}, {}, {}, {
    factory: ConfigurableExtensionDataRef<AnyApiFactory, "core.api.factory", {}>;
}>;

/**
 * Creates extensions that render a React element at the app root, outside of
 * the app layout. This is useful for example for shared popups and similar.
 *
 * @public
 */
declare const AppRootElementBlueprint: ExtensionBlueprint<{
    kind: "app-root-element";
    namespace: undefined;
    name: undefined;
}, {
    element: JSX.Element | (() => JSX.Element);
}, ConfigurableExtensionDataRef<React.JSX.Element, "core.reactElement", {}>, {}, {}, {}, never>;

/**
 * Creates a extensions that render a React wrapper at the app root, enclosing
 * the app layout. This is useful for example for adding global React contexts
 * and similar.
 *
 * @public
 */
declare const AppRootWrapperBlueprint: ExtensionBlueprint<{
    kind: "app-root-wrapper";
    namespace: undefined;
    name: undefined;
}, {
    Component: ComponentType<PropsWithChildren<{}>>;
}, ConfigurableExtensionDataRef<React__default.ComponentType<{
    children?: React__default.ReactNode;
}>, "app.root.wrapper", {}>, {}, {}, {}, {
    component: ConfigurableExtensionDataRef<React__default.ComponentType<{
        children?: React__default.ReactNode;
    }>, "app.root.wrapper", {}>;
}>;

/** @public */
declare const IconBundleBlueprint: ExtensionBlueprint<{
    kind: "icon-bundle";
    namespace: "app";
    name: undefined;
}, {
    icons: {
        [x: string]: IconComponent;
    };
}, ConfigurableExtensionDataRef<{
    [x: string]: IconComponent;
}, "core.icons", {}>, {}, {
    icons: string;
    test: string;
}, {
    test: string;
    icons?: string | undefined;
}, {
    icons: ConfigurableExtensionDataRef<{
        [x: string]: IconComponent;
    }, "core.icons", {}>;
}>;

/**
 * Creates extensions that make up the items of the nav bar.
 *
 * @public
 */
declare const NavItemBlueprint: ExtensionBlueprint<{
    kind: "nav-item";
    namespace: undefined;
    name: undefined;
}, {
    title: string;
    icon: IconComponent$1;
    routeRef: RouteRef<undefined>;
}, ConfigurableExtensionDataRef<{
    title: string;
    icon: IconComponent$1;
    routeRef: RouteRef<undefined>;
}, "core.nav-item.target", {}>, {}, {}, {}, {
    target: ConfigurableExtensionDataRef<{
        title: string;
        icon: IconComponent$1;
        routeRef: RouteRef<undefined>;
    }, "core.nav-item.target", {}>;
}>;

/**
 * Creates an extension that replaces the logo in the nav bar with your own.
 *
 * @public
 */
declare const NavLogoBlueprint: ExtensionBlueprint<{
    kind: "nav-logo";
    namespace: undefined;
    name: undefined;
}, {
    logoIcon: JSX.Element;
    logoFull: JSX.Element;
}, ConfigurableExtensionDataRef<{
    logoIcon?: JSX.Element | undefined;
    logoFull?: JSX.Element | undefined;
}, "core.nav-logo.logo-elements", {}>, {}, {}, {}, {
    logoElements: ConfigurableExtensionDataRef<{
        logoIcon?: JSX.Element | undefined;
        logoFull?: JSX.Element | undefined;
    }, "core.nav-logo.logo-elements", {}>;
}>;

/**
 * Createx extensions that are routable React page components.
 *
 * @public
 */
declare const PageBlueprint: ExtensionBlueprint<{
    kind: "page";
    namespace: undefined;
    name: undefined;
}, {
    defaultPath: string;
    loader: () => Promise<JSX.Element>;
    routeRef?: RouteRef<AnyRouteRefParams> | undefined;
}, ConfigurableExtensionDataRef<React.JSX.Element, "core.reactElement", {}> | ConfigurableExtensionDataRef<string, "core.routing.path", {}> | ConfigurableExtensionDataRef<RouteRef<AnyRouteRefParams>, "core.routing.ref", {
    optional: true;
}>, {}, {
    path: string | undefined;
}, {
    path?: string | undefined;
}, never>;

/** @public */
declare const RouterBlueprint: ExtensionBlueprint<{
    kind: "app-router-component";
    namespace: undefined;
    name: undefined;
}, {
    Component: ComponentType<PropsWithChildren<{}>>;
}, ConfigurableExtensionDataRef<ComponentType<{
    children?: React.ReactNode;
}>, "app.router.wrapper", {}>, {}, {}, {}, {
    component: ConfigurableExtensionDataRef<ComponentType<{
        children?: React.ReactNode;
    }>, "app.router.wrapper", {}>;
}>;

/**
 * Creates an extension that replaces the sign in page.
 *
 * @public
 */
declare const SignInPageBlueprint: ExtensionBlueprint<{
    kind: "sign-in-page";
    namespace: undefined;
    name: undefined;
}, {
    loader: () => Promise<ComponentType<SignInPageProps>>;
}, ConfigurableExtensionDataRef<React__default.ComponentType<SignInPageProps>, "core.sign-in-page.component", {}>, {}, {}, {}, {
    component: ConfigurableExtensionDataRef<React__default.ComponentType<SignInPageProps>, "core.sign-in-page.component", {}>;
}>;

/**
 * Creates an extension that adds/replaces an app theme.
 *
 * @public
 */
declare const ThemeBlueprint: ExtensionBlueprint<{
    kind: "theme";
    namespace: "app";
    name: undefined;
}, {
    theme: AppTheme;
}, ConfigurableExtensionDataRef<AppTheme, "core.theme.theme", {}>, {}, {}, {}, {
    theme: ConfigurableExtensionDataRef<AppTheme, "core.theme.theme", {}>;
}>;

/**
 * Creates an extension that adds translations to your app.
 *
 * @public
 */
declare const TranslationBlueprint: ExtensionBlueprint<{
    kind: "translation";
    namespace: undefined;
    name: undefined;
}, {
    resource: TranslationResource | TranslationMessages;
}, ConfigurableExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
    [x: string]: string;
}, boolean>, "core.translation.translation", {}>, {}, {}, {}, {
    translation: ConfigurableExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
        [x: string]: string;
    }, boolean>, "core.translation.translation", {}>;
}>;

/**
 * @public
 * @deprecated Use {@link ApiBlueprint} instead.
 */
declare function createApiExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: ({
    api: AnyApiRef;
    factory: (options: {
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => AnyApiFactory;
} | {
    factory: AnyApiFactory;
}) & {
    configSchema?: PortableSchema<TConfig>;
    inputs?: TInputs;
}): ExtensionDefinition<TConfig, TConfig, never, never, {
    kind?: string | undefined;
    namespace?: string | undefined;
    name?: string | undefined;
}>;
/**
 * @public
 * @deprecated Use {@link ApiBlueprint} instead.
 */
declare namespace createApiExtension {
    /**
     * @deprecated Use {@link ApiBlueprint} instead.
     */
    const factoryDataRef: ConfigurableExtensionDataRef<AnyApiFactory, "core.api.factory", {}>;
}

/**
 * Creates an extension that renders a React element at the app root, outside of
 * the app layout. This is useful for example for shared popups and similar.
 *
 * @public
 * @deprecated Use {@link AppRootElementBlueprint} instead.
 */
declare function createAppRootElementExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    element: JSX$1.Element | ((options: {
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        config: TConfig;
    }) => JSX$1.Element);
}): ExtensionDefinition<TConfig>;

/**
 * Creates an extension that renders a React wrapper at the app root, enclosing
 * the app layout. This is useful for example for adding global React contexts
 * and similar.
 *
 * @public
 * @deprecated Use {@link AppRootWrapperBlueprint} instead.
 */
declare function createAppRootWrapperExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    Component: ComponentType<PropsWithChildren<{
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        config: TConfig;
    }>>;
}): ExtensionDefinition<TConfig>;
/**
 * @public
 * @deprecated Use {@link AppRootWrapperBlueprint} instead.
 */
declare namespace createAppRootWrapperExtension {
    /**
     * @deprecated Use {@link AppRootWrapperBlueprint} instead.
     */
    const componentDataRef: ConfigurableExtensionDataRef<React__default.ComponentType<{
        children?: React__default.ReactNode;
    }>, "app.root.wrapper", {}>;
}

/**
 * Creates an extension that replaces the router implementation at the app root.
 * This is useful to be able to for example replace the BrowserRouter with a
 * MemoryRouter in tests, or to add additional props to a BrowserRouter.
 *
 * @public
 * @deprecated Use {@link RouterBlueprint} instead.
 */
declare function createRouterExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    Component: ComponentType<PropsWithChildren<{
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        config: TConfig;
    }>>;
}): ExtensionDefinition<TConfig>;
/**
 * @public
 * @deprecated Use {@link RouterBlueprint} instead.
 */
declare namespace createRouterExtension {
    /**
     * @deprecated Use {@link RouterBlueprint} instead.
     */
    const componentDataRef: ConfigurableExtensionDataRef<React__default.ComponentType<{
        children?: React__default.ReactNode;
    }>, "app.router.wrapper", {}>;
}

/**
 * Helper for creating extensions for a routable React page component.
 *
 * @public
 * @deprecated Use {@link PageBlueprint} instead.
 */
declare function createPageExtension<TConfig extends {
    path: string;
}, TInputs extends AnyExtensionInputMap>(options: ({
    defaultPath: string;
} | {
    configSchema: PortableSchema<TConfig>;
}) & {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    loader: (options: {
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => Promise<JSX.Element>;
}): ExtensionDefinition<TConfig>;

/**
 * Helper for creating extensions for a nav item.
 *
 * @public
 * @deprecated Use {@link NavItemBlueprint} instead.
 */
declare function createNavItemExtension(options: {
    namespace?: string;
    name?: string;
    routeRef: RouteRef<undefined>;
    title: string;
    icon: IconComponent$1;
}): ExtensionDefinition<{
    title: string;
}, {
    title?: string | undefined;
}, never, never, {
    kind?: string | undefined;
    namespace?: string | undefined;
    name?: string | undefined;
}>;
/**
 * @public
 * @deprecated Use {@link NavItemBlueprint} instead.
 */
declare namespace createNavItemExtension {
    /**
     * @deprecated Use {@link NavItemBlueprint} instead.
     */
    const targetDataRef: ConfigurableExtensionDataRef<{
        title: string;
        icon: IconComponent$1;
        routeRef: RouteRef<undefined>;
    }, "core.nav-item.target", {}>;
}

/**
 * Helper for creating extensions for a nav logos.
 *
 * @public
 * @deprecated Use {@link NavLogoBlueprint} instead.
 */
declare function createNavLogoExtension(options: {
    name?: string;
    namespace?: string;
    logoIcon: JSX.Element;
    logoFull: JSX.Element;
}): ExtensionDefinition<unknown, unknown, never, never, {
    kind?: string | undefined;
    namespace?: string | undefined;
    name?: string | undefined;
}>;
/**
 * @public
 * @deprecated Use {@link NavLogoBlueprint} instead.
 */
declare namespace createNavLogoExtension {
    /**
     * @deprecated Use {@link NavLogoBlueprint} instead.
     */
    const logoElementsDataRef: ConfigurableExtensionDataRef<{
        logoIcon?: JSX.Element | undefined;
        logoFull?: JSX.Element | undefined;
    }, "core.nav-logo.logo-elements", {}>;
}

/**
 *
 * @public
 * @deprecated Use {@link SignInPageBlueprint} instead.
 */
declare function createSignInPageExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    loader: (options: {
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => Promise<ComponentType<SignInPageProps>>;
}): ExtensionDefinition<TConfig>;
/**
 * @public
 * @deprecated Use {@link SignInPageBlueprint} instead.
 */
declare namespace createSignInPageExtension {
    /**
     * @deprecated Use {@link SignInPageBlueprint} instead.
     */
    const componentDataRef: ConfigurableExtensionDataRef<React__default.ComponentType<SignInPageProps>, "core.sign-in-page.component", {}>;
}

/**
 * @public
 * @deprecated Use {@link ThemeBlueprint} instead.
 */
declare function createThemeExtension(theme: AppTheme): ExtensionDefinition<unknown, unknown, never, never, {
    kind?: string | undefined;
    namespace?: string | undefined;
    name?: string | undefined;
}>;
/**
 * @public
 * @deprecated Use {@link ThemeBlueprint} instead.
 */
declare namespace createThemeExtension {
    const themeDataRef: ConfigurableExtensionDataRef<AppTheme, "core.theme.theme", {}>;
}

/** @public */
declare function createComponentExtension<TProps extends {}, TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    ref: ComponentRef<TProps>;
    name?: string;
    disabled?: boolean;
    /** @deprecated these will be removed in the future */
    inputs?: TInputs;
    /** @deprecated these will be removed in the future */
    configSchema?: PortableSchema<TConfig>;
    loader: {
        lazy: (values: {
            config: TConfig;
            inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        }) => Promise<ComponentType<TProps>>;
    } | {
        sync: (values: {
            config: TConfig;
            inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        }) => ComponentType<TProps>;
    };
}): ExtensionDefinition<TConfig, TConfig, never, never, {
    kind?: string | undefined;
    namespace?: string | undefined;
    name?: string | undefined;
}>;
/** @public */
declare namespace createComponentExtension {
    const componentDataRef: ConfigurableExtensionDataRef<{
        ref: ComponentRef;
        impl: ComponentType;
    }, "core.component.component", {}>;
}

/**
 * @public
 * @deprecated Use {@link TranslationBlueprint} instead.
 */
declare function createTranslationExtension(options: {
    name?: string;
    resource: TranslationResource | TranslationMessages;
}): ExtensionDefinition<unknown, unknown, never, never, {
    kind?: string | undefined;
    namespace?: string | undefined;
    name?: string | undefined;
}>;
/**
 * @public
 * @deprecated Use {@link TranslationBlueprint} instead.
 */
declare namespace createTranslationExtension {
    const translationDataRef: ConfigurableExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
        [x: string]: string;
    }, boolean>, "core.translation.translation", {}>;
}

export { type AnalyticsApi, AnalyticsContext, type AnalyticsContextValue, type AnalyticsEvent, type AnalyticsEventAttributes, type AnalyticsTracker, type AnyExtensionDataMap, type AnyExtensionDataRef, type AnyExtensionInputMap, type AnyExternalRoutes, type AnyRouteRefParams, type AnyRoutes, ApiBlueprint, type AppNode, type AppNodeEdges, type AppNodeInstance, type AppNodeSpec, AppRootElementBlueprint, AppRootWrapperBlueprint, type AppTree, type AppTreeApi, type BackstagePlugin, type CommonAnalyticsContext, type ComponentRef, type ComponentsApi, type ConfigurableExtensionDataRef, type CoreErrorBoundaryFallbackProps, type CoreNotFoundErrorPageProps, type CoreProgressProps, type CreateExtensionBlueprintOptions, type CreateExtensionOptions, type Extension, type ExtensionBlueprint, ExtensionBoundary, type ExtensionBoundaryProps, type ExtensionDataContainer, type ExtensionDataRef, type ExtensionDataRefToValue, type ExtensionDataValue, type ExtensionDataValues, type ExtensionDefinition, type ExtensionInput, type ExtensionOverrides, type ExtensionOverridesOptions, type ExternalRouteRef, type FeatureFlagConfig, type FrontendFeature, IconBundleBlueprint, type IconComponent, type IconsApi, type LegacyCreateExtensionOptions, type LegacyExtensionInput, NavItemBlueprint, NavLogoBlueprint, PageBlueprint, type PluginOptions, type PortableSchema, type ResolveInputValueOverrides, type ResolvedExtensionInput, type ResolvedExtensionInputs, type RouteFunc, type RouteRef, type RouteResolutionApi, type RouteResolutionApiResolveOptions, RouterBlueprint, SignInPageBlueprint, type SubRouteRef, ThemeBlueprint, TranslationBlueprint, analyticsApiRef, appTreeApiRef, componentsApiRef, coreComponentRefs, coreExtensionData, createApiExtension, createAppRootElementExtension, createAppRootWrapperExtension, createComponentExtension, createComponentRef, createExtension, createExtensionBlueprint, createExtensionDataRef, createExtensionInput, createExtensionOverrides, createExternalRouteRef, createFrontendPlugin, createNavItemExtension, createNavLogoExtension, createPageExtension, createPlugin, createRouteRef, createRouterExtension, createSchemaFromZod, createSignInPageExtension, createSubRouteRef, createThemeExtension, createTranslationExtension, iconsApiRef, routeResolutionApiRef, useAnalytics, useComponentRef, useRouteRef, useRouteRefParams };
